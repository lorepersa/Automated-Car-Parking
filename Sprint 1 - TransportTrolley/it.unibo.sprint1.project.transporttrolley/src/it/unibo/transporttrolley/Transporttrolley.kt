/* Generated by AN DISI Unibo */ 
package it.unibo.transporttrolley

import it.unibo.kactor.*
import alice.tuprolog.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
	
class Transporttrolley ( name: String, scope: CoroutineScope  ) : ActorBasicFsm( name, scope ){

	override fun getInitialState() : String{
		return "init"
	}
	@kotlinx.coroutines.ObsoleteCoroutinesApi
	@kotlinx.coroutines.ExperimentalCoroutinesApi			
	override fun getBody() : (ActorBasicFsm.() -> Unit){
		 
				var DESTINATION = "HOME"
				var car_taken_over = false
				var handling_job = false
				var auto_back_to_home = false
				val resource = itunibo.qakobserver.FactoryQakResource.create(myself)
				lateinit var status : itunibo.automatedcarparking.transporttrolley.TransportTrolleyStatus
				val jsonStatus = itunibo.automatedcarparking.utilities.JsonStatus
				lateinit var planner : itunibo.automatedcarparking.transporttrolley.planner.IPlanner
				val basicRobotUtil = itunibo.automatedcarparking.transporttrolley.basicrobot.BasicRobotUtility
				lateinit var watchdog : itunibo.qakutils.watchdog.Watchdog
				val transportTrolleyRolodex = itunibo.automatedcarparking.rolodex.TransportTrolleyRolodex
				
				lateinit var config : itunibo.automatedcarparking.transporttrolley.TransportTrolleyConfiguration
		return { //this:ActionBasciFsm
				state("init") { //this:State
					action { //it:State
						println("[transporttrolley] | [State] init | Entry point.")
						
									config = itunibo.automatedcarparking.configuration.TransportTrolleyConfigurationReader.read(transportTrolleyRolodex.filenameConfiguration)
									basicRobotUtil.setStepMoveDuration(config.stepMoveDuration)
									watchdog = itunibo.qakutils.watchdog.Watchdog(myself, config.timeLimitBackToHome, itunibo.automatedcarparking.transporttrolley.BackToHomeAutoMessage)
									planner = itunibo.automatedcarparking.transporttrolley.planner.PlannerFactory.create()
									planner.setPosition("HOME")
									val homePosition = planner.getCurrentPosition()
									status = itunibo.automatedcarparking.transporttrolley.TransportTrolleyStatus(stopped=false, idle=true, moveFailed=false, coordinate=homePosition)
									resource.notify(jsonStatus.getJsonString(status))
						println("[transporttrolley] | [State] init | Exit point.")
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
				state("wait") { //this:State
					action { //it:State
						println("[transporttrolley] | [State] wait | Entry point.")
						println("[transporttrolley] | [State] wait | Exit point.")
					}
					 transition(edgeName="t00",targetState="handleResumableMessages",cond=whenDispatch("transport_trolley_start"))
					transition(edgeName="t01",targetState="handleResumableMessages",cond=whenDispatch("transport_trolley_stop"))
					transition(edgeName="t02",targetState="handleNewJob",cond=whenRequestGuarded("transport_trolley_new_job",{ !status.stopped && !handling_job  
					}))
					transition(edgeName="t03",targetState="handleNewDestination",cond=whenRequestGuarded("transport_trolley_go_to",{ !status.stopped  
					}))
					transition(edgeName="t04",targetState="handleMoveReply",cond=whenDispatchGuarded("move_done",{ !status.stopped  
					}))
					transition(edgeName="t05",targetState="handleMoveReply",cond=whenDispatchGuarded("move_fail",{ !status.stopped  
					}))
					transition(edgeName="t06",targetState="convertStepReply",cond=whenReply("stepdone"))
					transition(edgeName="t07",targetState="convertStepReply",cond=whenReply("stepfail"))
					transition(edgeName="t08",targetState="handleCarTask",cond=whenRequestGuarded("transport_trolley_take_over_car",{ !status.stopped  
					}))
					transition(edgeName="t09",targetState="handleCarTask",cond=whenRequestGuarded("transport_trolley_release_car",{ !status.stopped  
					}))
					transition(edgeName="t010",targetState="handleJobDone",cond=whenDispatch("transport_trolley_job_done"))
					transition(edgeName="t011",targetState="handleGoHome",cond=whenDispatchGuarded("auto_transport_trolley_go_home",{ !status.stopped  
					}))
				}	 
				state("handleResumableMessages") { //this:State
					action { //it:State
						println("[transporttrolley] | [State] handleResumableMessages | Entry point.")
						if( checkMsgContent( Term.createTerm("transport_trolley_start(X)"), Term.createTerm("transport_trolley_start(X)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								println("[transporttrolley] | [State] handleResumableMessages | Received START!.")
								 status.stopped = false  
								if(  status.moveFailed  
								 ){println("[transporttrolley] | [State] handleResumableMessages | Last move is failed, reposition transport trolley at HOME!.")
								 planner.setPosition("HOME")  
								 status.coordinate = planner.getCurrentPosition()  
								if(  !DESTINATION.equals("HOME", true)  
								 ){println("[transporttrolley] | [State] handleResumableMessages | Uh, need to replan a path to $DESTINATION starting from HOME...")
								 planner.buildPlan(DESTINATION)  
								}
								else
								 {println("[transporttrolley] | [State] handleResumableMessages | Uh, destination is HOME and I am arrived at HOME now!")
								 if(  handling_job  
								  ){answer("transport_trolley_go_to", "transport_trolley_arrived_at", "transport_trolley_arrived_at(HOME)"   )  
								 }
								 else
								  { status.idle = true  
								  }
								 }
								 auto_back_to_home = false  
								 status.moveFailed = false  
								}
								if(  !planner.isWaitingMoveResult()  
								 ){ 
												val move = planner.nextMove()
												move?.let {
													println("[transporttrolley] | [State] handleResumableMessages | Doing move $move...")
													basicRobotUtil.sendMove(myself, move)
												}
								}
						}
						if( checkMsgContent( Term.createTerm("transport_trolley_stop(X)"), Term.createTerm("transport_trolley_stop(X)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								println("[transporttrolley] | [State] handleResumableMessages | Received STOP!.")
								 status.stopped = true  
						}
						 resource.notify(jsonStatus.getJsonString(status)) 
						println("[transporttrolley] | [State] handleResumableMessages | Exit point.")
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
				state("convertStepReply") { //this:State
					action { //it:State
						println("[transporttrolley] | [State] convertStepReply | Entry point.")
						if( checkMsgContent( Term.createTerm("stepdone(V)"), Term.createTerm("stepdone(X)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								println("[transporttrolley] | [State] convertStepReply | Received stepdone!")
								 myself.autoMsg("move_done", "move_done(w)")  
						}
						if( checkMsgContent( Term.createTerm("stepfail(DURATION,CAUSE)"), Term.createTerm("stepfail(DURATION,CAUSE)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								 val DURATION = payloadArg(0)  
								 val CAUSE = payloadArg(1)  
								println("[transporttrolley] | [State] convertStepReply | Received stepfail with {duration: $DURATION ms, cause: $CAUSE}...")
								 myself.autoMsg("move_fail", "move_fail(w,$DURATION,$CAUSE)")  
						}
						println("[transporttrolley] | [State] convertStepReply | Entry point.")
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
				state("handleMoveReply") { //this:State
					action { //it:State
						println("[transporttrolley] | [State] handleMoveReply | Entry point.")
						 var doUpdate = false  
						if( checkMsgContent( Term.createTerm("move_done(MOVE)"), Term.createTerm("move_done(MOVE)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								println("[transporttrolley] | [State] handleMoveReply | Move done.")
								
												val MOVE_DONE = payloadArg(0)
												planner.moveDone()
												status.moveFailed = false
												
												if (config.updatePositionAfterEachStep) {
													if (MOVE_DONE.equals("w", true)) {
														status.coordinate = planner.getCurrentPosition()
														doUpdate = true
													}
												} 
												
												
												val move = planner.nextMove()
												if (move != null) {
													println("[transporttrolley] | [State] handleMoveReply | Doing move $move...")
													basicRobotUtil.sendMove(myself, move)
												} else {
													
													// reached destination...
													println("[transporttrolley] | [State] handleMoveReply | Reached destination $DESTINATION!") 
													
													if (!DESTINATION.equals("HOME", true) || !auto_back_to_home) {
								answer("transport_trolley_go_to", "transport_trolley_arrived_at", "transport_trolley_arrived_at($DESTINATION)"   )  
								
													}
													
													if (DESTINATION.equals("HOME", true) && auto_back_to_home) {
														status.idle = true
													}
													
													auto_back_to_home = false
													status.coordinate = planner.getCurrentPosition()
													
													doUpdate = true
												}
						}
						if( checkMsgContent( Term.createTerm("move_fail(MOVE,DURATION,CAUSE)"), Term.createTerm("move_fail(MOVE,DURATION,CAUSE)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								 val CAUSE = payloadArg(2)  
								println("[transporttrolley] | [State] handleMoveReply | Failure: $CAUSE.")
								 planner.moveFail()  
								 status.stopped = true  
								 status.moveFailed = true  
								 doUpdate = true  
						}
						if(  doUpdate  
						 ){ resource.notify(jsonStatus.getJsonString(status))  
						}
						println("[transporttrolley] | [State] handleMoveReply | Exit point.")
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
				state("handleNewJob") { //this:State
					action { //it:State
						println("[transporttrolley] | [State] handleNewJob | Entry point.")
						 handling_job = true  
						 watchdog.stop()  
						 status.idle = false  
						 resource.notify(jsonStatus.getJsonString(status))  
						answer("transport_trolley_new_job", "transport_trolley_job_accepted", "transport_trolley_job_accepted(X)"   )  
						println("[transporttrolley] | [State] handleNewJob | Exit point.")
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
				state("handleNewDestination") { //this:State
					action { //it:State
						println("[transporttrolley] | [State] handleNewDestination | Entry point.")
						if( checkMsgContent( Term.createTerm("transport_trolley_go_to(DESTINATION)"), Term.createTerm("transport_trolley_go_to(DESTINATION)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								
											DESTINATION = payloadArg(0)
											println("[transporttrolley] | [State] handleNewDestination | Received destination: $DESTINATION.") 
											val ok = planner.buildPlan(DESTINATION)
											if (ok) {
												println("[transporttrolley] | [State] handleNewDestination | Known destination!.") 
												if (!planner.isWaitingMoveResult()) {
													val move = planner.nextMove()
													if (move != null) {
														println("[transporttrolley] | [State] handleNewDestination | Doing move $move...")
														basicRobotUtil.sendMove(myself, move)
													} else {
								println("[transporttrolley] | [State] handleNewDestination | I'm already at $DESTINATION...")
								answer("transport_trolley_go_to", "transport_trolley_arrived_at", "transport_trolley_arrived_at($DESTINATION)"   )  
								
													}
												}
												// else the first move of the new plan will be handled when the current move terminates...
											} else {
												println("[transporttrolley] | [State] handleNewDestination | Unknown destination...") 
								answer("transport_trolley_go_to", "transport_trolley_error", "transport_trolley_error(UNKNOWN_DESTINATION)"   )  
								
											}
											
											auto_back_to_home = false
						}
						println("[transporttrolley] | [State] handleNewDestination | Exit point.")
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
				state("handleJobDone") { //this:State
					action { //it:State
						println("[transporttrolley] | [State] handleJobDone | Entry point.")
						 handling_job = false  
						if(  planner.isHomePosition(planner.getCurrentPosition())  
						 ){ status.idle = true  
						}
						else
						 { watchdog.start()  
						 }
						println("[transporttrolley] | [State] handleJobDone | Exit point.")
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
				state("handleGoHome") { //this:State
					action { //it:State
						println("[transporttrolley] | [State] handleGoHome | Entry point.")
						if(  !handling_job  
						 ){
									DESTINATION = "HOME"
									planner.buildPlan("HOME")
									auto_back_to_home = true
									
									if (!planner.isWaitingMoveResult()) {
										val move = planner.nextMove() 
									
										if (move != null) {
											println("[transporttrolley] | [State] handleGoHome | Doing move $move...")
											basicRobotUtil.sendMove(myself, move)
										} else {
											println("[transporttrolley] | [State] handleGoHome | I'm already at HOME...")
											auto_back_to_home = false
										}
									}
									
						}
						else
						 {println("[transporttrolley] | [State] handleGoHome | Skipping auto back to HOME because I'm handling another job...")
						 }
						println("[transporttrolley] | [State] handleGoHome | Exit point.")
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
				state("handleCarTask") { //this:State
					action { //it:State
						println("[transporttrolley] | [State] handleCarTask | Entry point.")
						if( checkMsgContent( Term.createTerm("transport_trolley_take_over_car(X)"), Term.createTerm("transport_trolley_take_over_car(X)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								if(  !car_taken_over  
								 ){println("[transporttrolley] | [State] handleCarTask | Taking over car...")
								delay(1000) 
								 car_taken_over = true  
								println("[transporttrolley] | [State] handleCarTask | Car taken over!")
								answer("transport_trolley_take_over_car", "transport_trolley_car_taken_over", "transport_trolley_car_taken_over(X)"   )  
								}
								else
								 { val REASON = "CANNOT TAKE OVER MORE THAN ONE CAR" 
								 answer("transport_trolley_take_over_car", "transport_trolley_error", "transport_trolley_error($REASON)"   )  
								 }
						}
						if( checkMsgContent( Term.createTerm("transport_trolley_release_car(X)"), Term.createTerm("transport_trolley_release_car(X)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								if(  car_taken_over  
								 ){println("[transporttrolley] | [State] handleCarTask | Releasing car...")
								delay(1000) 
								 car_taken_over = false  
								println("[transporttrolley] | [State] handleCarTask | Car released!")
								answer("transport_trolley_release_car", "transport_trolley_car_released", "transport_trolley_car_released(X)"   )  
								}
								else
								 { val REASON = "NO CAR TAKED OVER"  
								 answer("transport_trolley_release_car", "transport_trolley_error", "transport_trolley_error($REASON)"   )  
								 }
						}
						println("[transporttrolley] | [State] handleCarTask | Exit point.")
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
			}
		}
}
