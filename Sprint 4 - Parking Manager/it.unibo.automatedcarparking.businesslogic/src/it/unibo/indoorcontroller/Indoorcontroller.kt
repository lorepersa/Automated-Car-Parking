/* Generated by AN DISI Unibo */ 
package it.unibo.indoorcontroller

import it.unibo.kactor.*
import alice.tuprolog.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
	
class Indoorcontroller ( name: String, scope: CoroutineScope  ) : ActorBasicFsm( name, scope ){

	override fun getInitialState() : String{
		return "init"
	}
	@kotlinx.coroutines.ObsoleteCoroutinesApi
	@kotlinx.coroutines.ExperimentalCoroutinesApi			
	override fun getBody() : (ActorBasicFsm.() -> Unit){
		
				// configurable variables...
				lateinit var DOOR_NAME : String
				var WMAX : Long = 0
				
				// internal status...
				var SLOTNUM = 0
				var TOKENID = ""
				var CAR_ENTER_SLOTNUM = SLOTNUM
				var CAR_ENTER_TOKENID = TOKENID
				var reserved_parking_slot = false
				var parking_car_interest = false
				var handling_car_enter = false 
				var wait_for_take_over = false
				var need_to_start_dtcarenter_timer = false
				
				val resource = itunibo.qakobserver.FactoryQakResource.create(myself)
				
				data class Weight(val weight : Int) {}
				
				val weightMessageBuilder = object : itunibo.qakobserver.IMessageBuilder {
					
					val gson = com.google.gson.Gson()
					override fun buildMessage(input : String, observerName : String) : ApplMessage {
						val weight = gson.fromJson(input, Weight::class.java).weight
						return MsgUtil.buildEvent(observerName, "auto_indoor_area_weight", "auto_indoor_area_weight($weight)")
					}
				}
				
				val weightsensorObserver = itunibo.qakobserver.FactoryQakObserver.create(myself, "weightsensor", weightMessageBuilder)
				
				val parkingAreaRolodex = itunibo.automatedcarparking.rolodex.ParkingAreaRolodex
				
				lateinit var dtoccupiedWatchdog : itunibo.qakutils.watchdog.Watchdog 
				lateinit var dtcarenterWatchdog : itunibo.qakutils.watchdog.Watchdog
				val status = itunibo.automatedcarparking.parkingarea.IndoorAreaStatus(false, false, false)
				val gson = com.google.gson.Gson()
				
				fun getJsonStatus() : String {
					return gson.toJson(status) 
				}
		return { //this:ActionBasciFsm
				state("init") { //this:State
					action { //it:State
						 val config = itunibo.automatedcarparking.configuration.IndoorAreaConfigurationReader.read(parkingAreaRolodex.filenameIndoorAreaConfiguration)  
						 WMAX = config.WMAX  
						 DOOR_NAME = config.doorName  
						 val DTOCCUPIED_TIMEOUT = config.DTOCCUPIED  
						 val DTCARENTER_TIMEOUT = config.DTCARENTER  
						 dtoccupiedWatchdog = itunibo.qakutils.watchdog.Watchdog(myself, DTOCCUPIED_TIMEOUT, itunibo.automatedcarparking.parkingarea.IndoorAreaDtoccupiedTimeoutAutoMessage)  
						 dtcarenterWatchdog = itunibo.qakutils.watchdog.Watchdog(myself, DTCARENTER_TIMEOUT, itunibo.automatedcarparking.parkingarea.IndoorAreaDtcarenterTimeoutAutoMessage)  
						println("[indoorcontroller] | init | Config - WMAX: $WMAX kG")
						println("[indoorcontroller] | init | Config - Door Name: $DOOR_NAME")
						println("[indoorcontroller] | init | Config - DTOCCUPIED Timeout: $DTOCCUPIED_TIMEOUT ms")
						println("[indoorcontroller] | init | Config - DTCARENTER Timeout: $DTCARENTER_TIMEOUT ms")
						 resource.notify(getJsonStatus())  
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
				state("wait") { //this:State
					action { //it:State
					}
					 transition(edgeName="t00",targetState="handleParkingCarInterest",cond=whenRequestGuarded("parking_car_interest",{ !status.reserved  
					}))
					transition(edgeName="t01",targetState="handleCarEnter",cond=whenRequestGuarded("car_enter",{ !handling_car_enter  
					}))
					transition(edgeName="t02",targetState="handleParkingSlot",cond=whenReply("parking_slot_reserved"))
					transition(edgeName="t03",targetState="handleParkingSlot",cond=whenReply("no_available_parking_slots"))
					transition(edgeName="t04",targetState="handleCarTakeOver",cond=whenDispatch("auto_car_taken_over"))
					transition(edgeName="t05",targetState="handleCarParkDone",cond=whenDispatch("auto_car_park_done"))
					transition(edgeName="t06",targetState="handleWeight",cond=whenEventGuarded("auto_indoor_area_weight",{ weightsensorObserver.isObserving()  
					}))
					transition(edgeName="t07",targetState="handleEnterIndoorAreaTimeout",cond=whenEventGuarded("auto_dtoccupied_timeout",{ dtoccupiedWatchdog.isRunning()  
					}))
					transition(edgeName="t08",targetState="handleCarEnterTimeout",cond=whenEventGuarded("auto_dtcarenter_timeout",{ dtcarenterWatchdog.isRunning()  
					}))
				}	 
				state("handleWeight") { //this:State
					action { //it:State
						 var update_status = false  
						println("$name in ${currentState.stateName} | $currentMsg")
						if( checkMsgContent( Term.createTerm("auto_indoor_area_weight(W)"), Term.createTerm("auto_indoor_area_weight(W)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								 val W = payloadArg(0).toInt()  
								if(  W > WMAX  
								 ){println("[indoorcontroller] | [State] handleWeight | Received Weight > WMAX!")
								if(  dtoccupiedWatchdog.isRunning()  
								 ){println("[indoorcontroller] | [State] handleWeight | Stop DTOCCUPIED timer...")
								 dtoccupiedWatchdog.stop()  
								if(  !handling_car_enter  
								 ){println("[indoorcontroller] | [State] handleWeight | Start DTCARENTER timer...")
								 dtcarenterWatchdog.start()  
								}
								else
								 {println("[indoorcontroller] | [State] handleWeight | Postpone DTCARENTER timer (ongoing car enter request)...")
								  need_to_start_dtcarenter_timer = true  
								 }
								}
								if(  !status.engagedByCar  
								 ){ update_status = true  
								}
								println("[indoorcontroller] | [State] handleWeight | $DOOR_NAME Area engaged by car!")
								 status.engagedByCar = true  
								}
								else
								 {println("[indoorcontroller] | [State] handleWeight | Received Weight <= WMAX!")
								  need_to_start_dtcarenter_timer = false  
								 if(  !wait_for_take_over && reserved_parking_slot && status.engagedByCar  
								  ){println("[indoorcontroller] | [State] handleWeight | Undone parking slot reservation...")
								 forward("undone_reservation", "undone_reservation($SLOTNUM,$TOKENID)" ,"parkingslotscontroller" ) 
								  status.reserved = false  
								  reserved_parking_slot = false  
								  update_status = true  
								 }
								 if(  status.carEnterTimeoutAlarm  
								  ){println("[indoorcontroller] | [State] handleWeight | DTCARENTER alarm raised...")
								  status.carEnterTimeoutAlarm = false  
								  status.reserved = false  
								  update_status = true  
								 }
								 if(  !parking_car_interest && !wait_for_take_over && status.engagedByCar  
								  ){println("[indoorcontroller] | [State] handleWeight | $DOOR_NAME Area free!")
								 println("[indoorcontroller] | [State] handleWeight | Stop DTCARENTER timer...")
								 println("[indoorcontroller] | [State] handleWeight | Stop weightsensor observation...")
								  status.reserved = false  
								  dtcarenterWatchdog.stop()  
								  weightsensorObserver.cancel()  
								  update_status = true  
								 }
								  status.engagedByCar = false  
								 if(  parking_car_interest  
								  ){println("[indoorcontroller] | [State] handleWeight | Reserve parking slot...")
								  parking_car_interest = false  
								 request("reserve_parking_slot", "reserve_parking_slot(X)" ,"parkingslotscontroller" )  
								 }
								 }
						}
						if(  update_status  
						 ){ resource.notify(getJsonStatus())  
						}
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
				state("handleParkingCarInterest") { //this:State
					action { //it:State
						println("$name in ${currentState.stateName} | $currentMsg")
						if( checkMsgContent( Term.createTerm("parking_car_interest(X)"), Term.createTerm("parking_car_interest(X)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								println("[indoorcontroller] | [State] handleParkingCarInterest | Parking car interest!")
								 status.reserved = true  
								 parking_car_interest = true  
								println("[indoorcontroller] | [State] handleParkingCarInterest | Start weightsensor observation...")
								 weightsensorObserver.observe()  
								 resource.notify(getJsonStatus())  
						}
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
				state("handleParkingSlot") { //this:State
					action { //it:State
						println("$name in ${currentState.stateName} | $currentMsg")
						if( checkMsgContent( Term.createTerm("parking_slot_reserved(SLOTNUM,TOKENID)"), Term.createTerm("parking_slot_reserved(SLOTNUM,TOKENID)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								 SLOTNUM = payloadArg(0).toInt()  
								 TOKENID = payloadArg(1)  
								println("[indoorcontroller] | [State] handleParkingSlot | reserved slotnum $SLOTNUM with tokenid $TOKENID")
								answer("parking_car_interest", "inform_in", "inform_in($SLOTNUM)"   )  
								println("[indoorcontroller] | [State] handleParkingSlot | Start DTOCCUPIED timer...")
								 dtoccupiedWatchdog.start()  
								 reserved_parking_slot = true  
						}
						if( checkMsgContent( Term.createTerm("no_available_parking_slots(X)"), Term.createTerm("no_available_parking_slots(X)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								println("indoorcontroller | [State] handleParkingSlot | no parking slots available")
								answer("parking_car_interest", "inform_in", "inform_in(0)"   )  
								 status.reserved = false  
								 status.engagedByCar = false  
								 parking_car_interest = false  
								println("indoorcontroller | [State] handleParkingSlot | Stop weightsensor observation...")
								 weightsensorObserver.cancel()  
								 resource.notify(getJsonStatus())  
								 reserved_parking_slot = false  
						}
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
				state("handleEnterIndoorAreaTimeout") { //this:State
					action { //it:State
						println("$name in ${currentState.stateName} | $currentMsg")
						if( checkMsgContent( Term.createTerm("auto_dtoccupied_timeout(X)"), Term.createTerm("auto_dtoccupied_timeout(X)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								println("[indoorcontroller] | [State] handleEnterIndoorAreaTimeout | DTOCCUPIED timeout, do not consider anymore the $DOOR_NAME AREA reserved...")
								 status.reserved = false  
								 status.engagedByCar = false  
								println("[indoorcontroller] | [State] handleEnterIndoorAreaTimeout | Stop weightsensor observation...")
								 weightsensorObserver.cancel()  
								 dtoccupiedWatchdog.stop()  
								println("[indoorcontroller] | [State] handleEnterIndoorAreaTimeout | Undone parking slot reservation...")
								forward("undone_reservation", "undone_reservation($SLOTNUM,$TOKENID)" ,"parkingslotscontroller" ) 
								 reserved_parking_slot = false  
								 resource.notify(getJsonStatus())  
						}
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
				state("handleCarEnterTimeout") { //this:State
					action { //it:State
						println("$name in ${currentState.stateName} | $currentMsg")
						if( checkMsgContent( Term.createTerm("auto_dtcarenter_timeout(X)"), Term.createTerm("auto_dtcarenter_timeout(X)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								println("[indoorcontroller] | [State] handleCarEnterTimeout | DTCARENTER timeout, too much time elapsed, need to inform the manager...")
								 dtcarenterWatchdog.stop()  
								 status.carEnterTimeoutAlarm = true  
								 resource.notify(getJsonStatus())  
						}
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
				state("handleCarEnter") { //this:State
					action { //it:State
						println("$name in ${currentState.stateName} | $currentMsg")
						 var ok = true  
						if(  ok && !status.reserved  
						 ){answer("car_enter", "response_car_enter", "response_car_enter(IndoorAreaNotReserved)"   )  
						println("[indoorcontroller] | [State] handleCarEnter | Received car enter request but the $DOOR_NAME Area is not reserved...")
						 ok = false  
						}
						if(  ok && !status.engagedByCar  
						 ){answer("car_enter", "response_car_enter", "response_car_enter(IndoorAreaNotEngagedByCar)"   )  
						println("[indoorcontroller] | [State] handleCarEnter | Received car enter request but the $DOOR_NAME Area is not engaged by car...")
						 ok = false  
						}
						if(  ok  
						 ){if( checkMsgContent( Term.createTerm("car_enter(SLOTNUM)"), Term.createTerm("car_enter(SLOTNUM)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								 val INPUT_SLOTNUM = payloadArg(0).toInt()  
								if(  INPUT_SLOTNUM == SLOTNUM  
								 ){ handling_car_enter = true  
								 CAR_ENTER_SLOTNUM = SLOTNUM  
								 val CACHED_SLOTNUM = SLOTNUM  
								 CAR_ENTER_TOKENID = TOKENID  
								 val CACHED_TOKENID = TOKENID  
								 wait_for_take_over = true  
								 dtcarenterWatchdog.stop()  
								if(  status.carEnterTimeoutAlarm  
								 ){ status.carEnterTimeoutAlarm = false  
								 resource.notify(getJsonStatus())  
								}
								println("[indoorcontroller] | [State] handleCarEnter | Handle valid car enter request {SLOTNUM: $CACHED_SLOTNUM, TOKENID: $CACHED_TOKENID}")
								 val doorName = DOOR_NAME  
								
														myself.scope.launch {
															itunibo.automatedcarparking.dsl.transporttrolley.transporttrolley {
																task {
																	println("[indoorcontroller] | Move the transport trolley to $doorName...")
																	takeOverCar at doorName
																
																	myself.autoMsg("auto_car_taken_over", "auto_car_taken_over(X)")
								
																	println("[indoorcontroller] | Move the transport trolley to SLOTNUM $CACHED_SLOTNUM...")
																	releaseCar at "$CACHED_SLOTNUM"
																}
															}
															myself.autoMsg("auto_car_park_done", "auto_car_park_done(X)")
														}
								}
								else
								 {println("[indoorcontroller] | [State] handleCarEnter | Received car enter request with SLOTNUM $INPUT_SLOTNUM different from expected SLOTNUM $SLOTNUM...")
								 answer("car_enter", "response_car_enter", "response_car_enter(InvalidSlotnum)"   )  
								 }
						}
						}
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
				state("handleCarTakeOver") { //this:State
					action { //it:State
						println("[indoorcontroller] | [State] handleCarTakeOver")
						println("[indoorcontroller] | [State] handleCarTakeOver | Send TOKENID $TOKENID to the user...")
						answer("car_enter", "response_car_enter", "response_car_enter($TOKENID)"   )  
						 wait_for_take_over = false  
						 reserved_parking_slot = false  
						if(  !status.engagedByCar  
						 ){println("[indoorcontroller] | [State] handleCarTakeOver | $DOOR_NAME Area free!")
						 status.reserved = false  
						println("[indoorcontroller] | [State] handleCarTakeOver | Stop weightsensor observation...")
						 weightsensorObserver.cancel()  
						 resource.notify(getJsonStatus())  
						}
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
				state("handleCarParkDone") { //this:State
					action { //it:State
						println("[indoorcontroller] | [State] handleCarParkDone")
						 handling_car_enter = false  
						println("[indoorcontroller] | [State] handleCarParkDone | Confirm mapping between parking slot $CAR_ENTER_SLOTNUM and TOKENID $CAR_ENTER_TOKENID...")
						forward("confirm_parking_slot", "confirm_parking_slot($CAR_ENTER_SLOTNUM,$CAR_ENTER_TOKENID)" ,"parkingslotscontroller" ) 
						if(  need_to_start_dtcarenter_timer  
						 ){println("[indoorcontroller] | [State] handleCarParkDone | Start DTCARENTER timer...")
						 need_to_start_dtcarenter_timer = false  
						 dtcarenterWatchdog.start()  
						}
					}
					 transition( edgeName="goto",targetState="wait", cond=doswitch() )
				}	 
			}
		}
}
