<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->

<head>
  <link href="style/style.css" rel="stylesheet" type="text/css">

<title>First Problem Analysis</title>
</head>

<body>
<div id="top">
<h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font> </h1>
</div>

<div class="body">
<h2>Introduction</h2>


<h2>Requirements</h2>


<div class="remark">
Customer's requirements are available <a href="https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.issLabStart/userDocs/TFBO21ISS.pdf">here</a>.
</div>



<h2>Requirement analysis</h2>

<div class="remark">
Requirements analysis is available <a href="http://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html">here</a>.
</div>

<h2>First Problem Analysis</h2>
<div class="remark">

  <div>
    <h3>Summary</h3>
    <ol>
      <li>
        <a href="#technologies-abstraction-gap">Technologies and abstraction gap</a>
      </li>
      <li>
        <a href="#general-considerations">General considerations</a>
      </li>
      <li>
        <a href="#weight-sensor">WeightSensor</a>
      </li>
      <li>
        <a href="#out-sonar">OutSonar</a>
      </li>
      <li>
        <a href="#thermometer">Thermometer</a>
      </li>
      <li>
        <a href="#fan">Fan</a>
      </li>
      <li>
        <a href="#transport-trolley">TransportTrolley</a>
      </li>
      <li>
        <a href="#park-service-gui">ParkServiceGUI</a>
      </li>
      <li>
        <a href="#park-service-status-gui">ParkServiceStatusGUI</a>
      </li>
      <li>
        <a href="#business-logic">Business Logic</a>
      </li>
      <li>
        <a href="#logical-architecture">Logical Architecture</a>
      </li>
      <li>
        <a href="#test-plan">Test Plan</a>
      </li>
      <li>
        <a href="#work-plan">Work Plan</a>
      </li>
    </ol>
  </div>

  <div class="technologies_abstraction_gap" id="technologies-abstraction-gap">
    <h3>Technologies and abstraction gap</h3>
    <p>
      An object oriented programming language, as Kotlin or Java, seems the best fit to implement the services of our system. Kotlin would be preferred for its native support for coroutines and actors that would benefit developers by not having to import many libraries and dependencies and, of course, in terms of resources, as coroutines are more lightweight than threads and don't need many expensive context switches.<br>
      This distributed system, made of several heterogeneous components, would benefit greatly from an actor-based framework with a support for a message-based interaction. For this purpose, the product owner provides us a custom modelling language (DSL) and metamodel, <k>QAK meta-model</k>, that will help us in building a model of the system exploiting actors technology, as a substitute for the usual object technology, to achieve high-level interaction between components, as the actors possess an inward message queue which can be used to communicate with a specific message-based application level protocol, which sits on top of the usual, most used transport and application level protocols (HTTP, WS, TCP, UDP, etc.). In addition the QAK meta-model provides compatibility with other communication protocols such as MQTT and CoAP, equally valid for the interaction between actors.
      <br><br>
      Thanks to the QAK meta-model that the customer gives to us there is not an abstraction gap for what is concerning the communication between actors, even if those actors are located in different nodes of a distributed system. A small abstraction gap found by the analysts was about the possibility to <k>observe</k> a QActor from another QActor: the QAK meta-model has a built-in support for updating a CoAP Resource of a specific QActor, what is natively missing is the support to observe this resource from other QActor. So the analysts decided to design and implement (in Kotlin) a small framework that integrates this feature in the QAK meta-model: thanks to the framework now there is the possibility to register a QActor as observer of another QActor and receive an update each time the (observable) CoAP Resource is updated; <a href="http://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/First%20Problem%20Analysis/it.unibo.qakobserver/userDocs/Documentation.html"><k>the framework has been documented in detail here</k></a>. In the rest of the document when we talk about observation between QActor we will implicitly refer to the possibility of using this framework. <br>
      The analysts found an abstraction gap also when they taken in consideration things like fault tolerance and a possible data persistence, because it requires the use of low level techniques to solve them. Moreover the use of physical sensors also increase the abstraction gap.
      <br><br>
    </p>
  </div>

  <div class="general_considerations" id="general-considerations">
    <h3>General Considerations</h3>
    <!-- IMAGE -->
    <div class="interactions__image">
      <center>
        <img src="./img/general_considerations_architecture.png" alt="general_considerations_architecture.png"/>
      </center>
    </div>
    <!-- CONSIDERATIONS -->
    <div>
      <p>
        The ParkManagerService (PMS) could be divided into three macro blocks:
        <ol>
          <li>
            <b>Entities</b>: they represent the physical components integrated into the system. There are three sensors (weight sensor, out sonar, thermometer) whose task is to perform measures (weight, distance, temperarature) and let them processable by the business logic. There are also two actuators (fan, basic robot) whose task is to receive and perform commands.
          </li>
          <li>
            <b>Domain Logic</b>: it is the core of the PMS. It contains all the logic necessary to process the sensors data, to command the actuators and to interact with the GUIs.
          </li>
          <li>
            <b>Gui</b>: they represent the Park Manager Service I/O. Their task is to receive input from human user and to show the output to them. A thing to carefully consider will be the design of the user interfaces.
          </li>
        </ol>
      </p>
    </div>
    <h3 id="legenda">
      Legenda
    </h3>
    <div class="interactions__image">
      <center>
        <img src="./img/legenda_interactions.png" style="width:30%;" alt="legenda_interactions.png"/>
      </center>
    </div>
  </div>

  <div class="component" id="weight-sensor">
    <h3>Weight Sensor</h3>
    <!-- DESCRIPTION -->
    <h4 id="weight-sensor-description">Description</h4>
    <p>
      The customer said that the weight sensor is a component working on its own computational node. For that reason we will design the weight sensor as a <k>QActor</k> working in its own <k>context</k> named <k>ctxweightsensor</k>. Moreover the customer did not give us any software to use for the weightsensor: we need to design and implement it from scratch.
      <br><br>
      The physical weightsensor is the entity able to measure autonomously the weight and can be modeled as an <k>active object</k> (e.g. a thread encapsulated in an object) <k>encapsulated</k> by the weightsensor QActor. The weightsensor QActor should be modeled as an entity able to inform the system about the measured weight. As per requirements the physical weightsensor should be a <k>mock</k> one, but as analysts we will keep in mind the possibility that the customer may want to use a real component in the future.
      <br>
      <k>In the document the unit of measurement of the weight is "kilogram (kG)" if not otherwise specified.</k>
    </p>
    <h4 id="weight-sensor-domain-logic">About the domain logic</h4>
      In our domain the weightsensor is located in the <k>INDOOR AREA</k> and a measured weight greater than a <k>configurable</k> threshold <k>WMAX</k> means that the INDOOR AREA is engaged by a car, otherwise the INDOOR AREA is free. Moreover since our domain is to detect the presence of a car we do not need an high precision sensor but we can assume the measured weight as a quantized "integer" information.
      <br><br>
      The resulting component is a QActor, <k>observable</k> via <k>CoAP</k>, that makes processable by the rest of the system (to whoever wants to register as observer of the weightsensor) the information about the current weight measured and, in particular, the business logic uses this information to check if the WMAX threshold has been exceeded or not.
    </p>
    <h4 id="weight-sensor-costs">About costs</h4>
    <p>
      About the cost of our choice we want to highlight the fact that in our domain the customer wants the ParkServiceStatusGUI "updated" each time the weight (and the logical information) changes in the INDOOR AREA. Moreover the business logic itself also needs the logical information (indoor area occupied or free) processed starting from the weight measured by the weightsensor, so using directly the updates received by the observer we avoid information redundancy. So is straightforward to think the business logic as an intermediary between the ParkServiceStatusGUI and the weightsensor in order to:
      <ol>
        <li>
          Reduce the computational load (and number of registered entities) in the weightsensor, because we have also in mind that a weightsensor, in a real world scenario, may be a low cost IoT board (at least for what is concerning the software component).
        </li>
        <li>
          Avoid security issues because in that way we do not need to expose the weightsensor in a web network.
        </li>
      </ol>
      Keeping in mind what we discussed above, there are basically three possibilities to receive these updates:
      <ol>
        <li>
          The business logic via a <k>polling</k> mechanism asks the information to the weightsensor. We discarded this possibility because there is a costant factor of network utilization even if the weightsensor does not measure any change for some time.
        </li>
        <li>
          The weightsensor emits <k>events</k> in order to be an isolated component. We discarded this possibility because the cost of deliver the events even to entities that are not interested in receiving those is too high.
        </li>
        <li>
          An <k>observer</k> remote pattern interaction (using CoAP) with updates to the registered observers done only when a changes in the measured weight has been detected. We choose this because the updates are notified only to the interested entities, so the bandwidth usage is minimized.
        </li>
      </ol>
      <br><br>
      Note that an update from the weightsensor to the businesslogic each time there is a minimal weight update may be too costly and not needed by the logic of the system. In fact the businesslogic itself is interested in the weight measured by the weightsensor only when it knows that a car is entering the indoor area. For that reason we strongly recommend to the projectist to let this feature <b>configurable</b> in order to let the system administrator choose between the two possible configuration:
      <ol>
        <li>
          The weightsensor constantly observed by the businesslogic in order to send to the manager a real-time updated information. As a cost we have a lot of not needed updates for the logic of the system.
        </li>
        <li>
          The weightsensor observed only when needed by the businesslogic. As a gain we reduce the number of not needed updates in the system. As a cost the manager cannot receive real-time updates on the measured weight, but it will receive updates only when the business logic is interested in the measured weight in the indoor area.
        </li>
      </ol>
    </p>

    <!-- INTERACTIONS -->
    <div width="100%" >
      <h4 id="weight-sensor-interactions">Interactions</h4>
      <!-- interaction image -->
      <div class="interactions__image">
        <center>
          <img src="./img/weight_sensor_interaction.png" alt="weight_sensor_interaction.png"/>
        </center>
      </div>
      <!-- interaction qak example -->
      <div class="interaction_qak_example">
        <h4 id="weight-sensor-qak">QAK Model</h4>
        <p>
          The following QAK is a machine readable format of what we discussed above. Given that in this model the weight sensor is a mock one, we can configure its weight via a particular dispatch <k>input_weight</k> in which the payload represents the current weight measured in the indoor area.
        </p>
        <a href="../it.unibo.first_problem_analysis.weightsensor/src/weightsensor.qak">
          <div class="interaction_qak_example_link">
            weight sensor.qak
          </div>
        </a>
      </div>
    </div>
  </div> <!-- end component -->

  <div class="component" id="out-sonar">
    <h3>Out Sonar</h3>
    <!-- DESCRIPTION -->
    <h4 id="out-sonar-description">Description</h4>
    <p>
      The customer said that the outsonar is a component working on its own computational node. For that reason we will design the weight sensor as a <k>QActor</k> working in its own <k>context</k> named <k>ctxoutsonar</k>. There is some software that the customer gives to us about the real sonar, named SonarAlone.c, that you can find <a href="https://github.com/anatali/issLab2021/blob/main/it.unibo.rasp2021/resources/rasp/sonar/SonarAlone.c">here</a>. Moreover the customer wants to see how the outsonar works in a scenario where the real sonar is physically connected to a Raspberry Pi.
      <br><br>
      The physical outsonar is the entity able to measure autonomously the distance within a fixed point and can be modeled as an <k>active object</k> (e.g. a thread encapsulated in an object) <k>encapsulated</k> by the QActor oustonar. The QActor outsonar is able to inform the system about the measured distance. As per requirements the physical outsonar should be a <k>real</k> one, but for the sake of simplicity we will use a mocked outsonar until we reach the real deployment phase.
      <br> <k>In the document the unit of measurement of the distance is "centimeter (cm)" if not otherwise specified.</k>
      <br>
    </p>
    <h4 id="out-sonar-domain-logic">About the domain logic</h4>
      In our domain the outsonar is located in the <k>OUTDOOR AREA</k> and a measured distance lower than a <k>configurable</k> threshold <k>DMIN</k> means that the OUTDOOR AREA is engaged by a car, otherwise the OUTDOOR AREA is free. We refer to the distance as an integer information.
      <br><br>
      The resulting component is a QActor, <k>observable</k> via <k>CoAP</k>, that makes processable by the rest of the system (to whoever wants to register as observer of the outsonar) the information about the current measured distance and, in particular, the business logic uses this information to check if the DMIN threshold has been exceeded or not.
    </p>
    <h4 id="out-sonar-costs">About costs</h4>
    <p>
      About the cost of our choice we want to highlight the fact that in our domain the ParkServiceStatusGUI needs to be "updated" each time the distance (and the logical information) changes in the OUTDOOR AREA. Moreover the business logic itself also needs the logical information processed by the outsonar, so using directly the updates received by the observer we avoid information redundancy. So is straightforward to think the business logic as an intermediary between the ParkServiceStatusGUI and the outsonar in order to:
      <ol>
        <li>
          Reduce the computational load (and number of registered entities) in the outsonar, because we have also in mind that a outsonar, in a real world scenario, may be a low cost IoT board (at least for what is concerning the software component).
        </li>
        <li>
          Avoid security issues because in that way we do not need to expose the outsonar in a web network.
        </li>
      </ol>
      Keeping in mind what we discussed above, there are basically three possibilities to receive these updates:
      <ol>
        <li>
          The business logic via a <k>polling</k> mechanism asks the information to the outsonar. We discarded this possibility because there is a costant factor of network utilization even if the outsonar does not measure any change for some time.
        </li>
        <li>
          The outsonar emits <k>events</k> in order to be an isolated component. We discarded this possibility because the cost of deliver the events even to entities that are not interested in receiving those is too high.
        </li>
        <li>
          An <k>observer</k> remote pattern interaction (using CoAP) with the updates to the registered observers done only when a change in the measured distance has been dectected. We choose this because the updates are notified only to the interested entities, so the bandwidth usage is minimized.
        </li>
      </ol>
      Note that an update from the outsonar to the businesslogic each time there is a minimal distance update may be too costly and not needed by the logic of the system. In fact the businesslogic itself is interested in the distance measured by the outsonar only when it has to handle a car pick up request until the car left the outdoor area. For that reason we strongly recommend to the projectist to let this feature <b>configurable</b> in order to let the system administrator choose between the two possible configuration:
      <ol>
        <li>
          The outsonar constantly observed by the businesslogic in order to send to the manager a real-time updated information. As a cost we have a lot of not needed updates for the logic of the system.
        </li>
        <li>
          The outsonar observed only when needed by the businesslogic. As a gain we reduce the number of not needed updates in the system. As a cost the manager cannot receive real-time updates on the measured distance, but it will receive updates only when the business logic is interested in the measured distance in the outdoor area.
        </li>
      </ol>
    </p>
    <!-- INTERACTIONS -->
    <div width="100%" >
      <h4 id="out-sonar-interactions">Interactions</h4>
      <!-- interaction image -->
      <div class="interactions__image">
        <center>
          <img src="./img/out_sonar_interaction.png" alt="out_sonar_interaction.png"/>
        </center>
      </div>
      </table>
      <!-- interaction qak example -->
      <div class="interaction_qak_example">
        <h4 id="out-sonar-qak">QAK Model</h4>
        <p>
          The following QAK is a machine readable format of what we discussed above. Given that in this model the outsonar is a mock one, we can configure its measured distance via a particular dispatch <k>input_distance</k> in which the payload represents the current distance measured in the outdoor area.
        </p>
        <a href="../it.unibo.first_problem_analysis.outsonar/src/outsonar.qak">
          <div class="interaction_qak_example_link">
            out sonar.qak
          </div>
        </a>
      </div>
    </div>
  </div> <!-- end component -->

  <div class="component" id="thermometer">
    <h3>Thermometer</h3>
    <!-- DESCRIPTION -->
    <h4 id="thermometer-description">Description</h4>
    <p>
      The customer said that the thermometer is a component working on its own computational node. For that reason we will design the thermometer as a <k>QActor</k> working in its own <k>context</k> named <k>ctxthermometer</k>. Moreover the customer did not give us any software to use for the thermometer: we need to design and implement it from scratch.
      <br><br>
      The physical thermometer is the entity able to measure autonomously the temperature and can be modeled as an <k>active object</k> (e.g. a thread encapsulated in an object) <k>encapsulated</k> by the logical entity. As per requirements the physical thermometer should be a <k>mock</k> one, but as analysts we will keep in mind the possibility that the customer may want to use a real component in the future.
      <br> <k>In the document the unit of measurement of the temperature is "celsius degree (°C)" if not otherwise specified.</k>
    </p>
    <h4 id="thermometer-domain-logic">About the domain logic</h4>
    <p>
      In our domain the thermometer is located in the parking area and a measured temperature greater than a <k>configurable</k> threshold <k>TMAX</k> means that the temperature is TOO HIGH, otherwise the temperature is LOW. We can assume the measured temperature as a quantized "integer" information.
      <br><br>
      The resulting component is a QActor, <k>observable</k> via <k>CoAP</k>, that makes processable by the rest of the system (to whoever wants to register as observer of the thermometer) the information about the current temperature measured and, in particular, this information is used by the business logic and by the manager to check if the TMAX threshold has been exceeded or not. Note that the business logic uses this information only when the fan is in automatically modality as explained in the <a href="#fan">fan section</a>, while the manager uses always this binary information to decide to start/stop the transport trolley and also to start/stop the fan when the modality is manual. <br>
      With the table below we want to emphasize when the decision about the start/stop of the transport trolley of the fan should be taken regarding to the value of the logical temperature; but keep always in mind that the transport trolley is manually controlled by the manager and that is true also for the fan in "manual mode", so the state transition from STARTED to STOPPED (and vice versa) might be not immediate when the temperature changes. Also note that is not a strict requirement to manually start/stop the fan and the transport trolley only when the temperature is greater than or lower than/equal to TMAX, the manager could take different decision.
      <table class="thermometer_table">
        <tr>
          <th></th>
          <th>FAN</th>
          <th>TRANSPORT TROLLEY</th>
        </tr>
        <tr>
          <td><b>T > TMAX</b></td>
          <td>STARTED</td>
          <td>STOPPED</td>
        </tr>
        <tr>
          <td><b>T <= TMAX</b></td>
          <td>STOPPED</td>
          <td>STARTED</td>
        </tr>
      </table>
      <br><br>
    </p>
    <h4 id="thermometer-costs">About costs</h4>
    <p>
      About the cost of our choice we want to highlight the fact that in our domain the ParkServiceStatusGUI needs to be "updated" each time the temperature (and the logical information) changes in the PARKING AREA. Moreover the business logic itself also needs the logical information processed by the thermometer (in order to command the automatic fan), so using directly the updates received by the observer we avoid information redundancy. So is straightforward to think the business logic as an intermediary between the ParkServiceStatusGUI and the thermometer in order to:
      <ol>
        <li>
          Reduce the computational load (and number of registered entities) in the thermometer, because we have also in mind that a thermometer, in a real world scenario, may be a low cost IoT board (at least for what is concerning the software component).
        </li>
        <li>
          Avoid security issues because in that way we do not need to expose the weightsensor in a web network.
        </li>
      </ol>
      Keeping in mind what we discussed above, there are basically three possibilities to receive these updates:
      <ol>
        <li>
          The business logic via a <k>polling</k> mechanism asks the information to the thermometer. We discarded this possibility because there is a costant factor of network utilization even if the thermometer does not measure any change for some time.
        </li>
        <li>
          The thermometer emits <k>events</k> in order to be an isolated component. We discarded this possibility because the cost of deliver the events even to entities that are not interested in receiving those is too high.
        </li>
        <li>
          An <k>observer</k> remote pattern interaction (using CoAP) with the updates to the registered observers done only when a change in the measured temperature has been dectected. We choose this because the updates are notified only to the interested entities, so the bandwidth usage is minimized.
        </li>
      </ol>
      Differently from the weightsensor and the outsonar for the thermometer the temperature is a necessary information for the entire duration of the application so there are not possibilities to let configurable to observe the thermometer only in particular moments and the businesslogic must observe it from the beginning.
    </p>
    <!-- INTERACTIONS -->
    <div width="100%" >
      <h4  id="thermometer-interactions">Interactions</h4>
      <!-- interaction image -->
      <div class="interactions__image">
        <center>
          <img src="./img/thermometer_interaction.png" alt="thermometer_interaction.png"/>
        </center>
      </div>
      <!-- interaction qak example -->
      <div class="interaction_qak_example">
        <h4  id="thermometer-qak">QAK Model</h4>
        <p>
          The following QAK is a machine readable format of what we discussed above. Given that in this model the thermometer is a mock one, we can configure its measured temperature via a particular dispatch <k>input_temperature</k> in which the payload represents the current temperature measured in the outdoor area.
        </p>
        <a href="../it.unibo.first_problem_analysis.thermometer/src/thermometer.qak">
          <div class="interaction_qak_example_link">
            thermometer.qak
          </div>
        </a>
      </div>
    </div>
  </div> <!-- end component -->

  <div class="component" id="fan">
    <h3>fan</h3>
    <!-- DESCRIPTION -->
    <h4 id="fan-description">Description</h4>
    <p>
      The customer said that the fan is a component working on its own computational node. For that reason we will design the fan as a <k>QActor</k> working in its own <k>context</k> named <k>ctxfan</k>. Moreover the customer did not give us any software to use for the fan: we need to design and implement it from scratch.
      <br><br>
    </p>
    <h4 id="fan-domain-logic">About the domain logic</h4>
    <p>
      The fan is an actuator able to be started/stopped via <k>request</k> and <k>reply</k> with the success or failure of the operation. <br>
      The fan should also works in two modality: manual and automatic. These two modalities do not affect the fan itself but they affect the business logic. <br><br>
      In fact, as anticipated in the <a href="#thermometer-domain-logic">thermometer section</a>, when the fan is in automatic mode the business logic, starting from the logical binary temperature (HIGH, LOW), has the task to start the fan when the temperature is HIGH and stop it when the temperature is LOW. A curious case to consider is the switch from the manual to the automatic mode, in fact since when the fan is in "manual control" we have not any guarantees that the manager has started/stopped it accordingly to the temperature HIGH or LOW, the business logic in the moment of the manual to automatic switch needs to verify that the relations TEMPERATURE LOW - FAN OFF or TEMPERATURE HIGH - FAN ON are satisfied, otherwise it has to start/stop the fan immediately. <br><br>
      When the fan is in manual modality it is controlled by the manager through the ParkServiceStatusGUI and for that reason the business logic in that case will acts only as an intermediary between the ParkServiceStatusGUI and the fan itself.
    </p>
    <!-- INTERACTIONS -->
    <div width="100%" >
      <h4 id="fan-interactions">Interactions</h4>
      <!-- interaction image -->
      <div class="interactions__image">
        <center>
          <img src="./img/fan_interaction.png" alt="fan_interaction.png"/>
        </center>
      </div>
      <table class="table_interactions_messages">
        <tr>
          <th>Message</th>
          <th>Payload</th>
          <th>Semantic</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>
            fan_on
          </td>
          <td>
            X
          </td>
          <td>
            request
          </td>
          <td>
            Asks to start the fan.
          </td>
        </tr>
        <tr>
          <td>
            fan_off
          </td>
          <td>
            X
          </td>
          <td>
            request
          </td>
          <td>
            Asks to stop the fan.
          </td>
        </tr>
        <tr>
          <td>
            fan_done
          </td>
          <td>
            X
          </td>
          <td>
            reply
          </td>
          <td>
            Success.
          </td>
        </tr>
        <tr>
          <td>
            fan_fail
          </td>
          <td>
            REASON
          </td>
          <td>
            reply
          </td>
          <td>
            Failure, the requested operation cannot be performed.
          </td>
        </tr>
      </table>
      <!-- interaction qak example -->
      <div class="interaction_qak_example">
        <h4 id="fan-qak">QAK Model</h4>
        <p>
          The following QAK is a machine readable format of what we discussed above
        </p>
        <a href="../it.unibo.first_problem_analysis.fan/src/fan.qak">
          <div class="interaction_qak_example_link">
            fan.qak
          </div>
        </a>
      </div>
    </div>
  </div> <!-- end component -->

  <div class="component" id="transport-trolley">
    <h3>Transport Trolley</h3>
    <!-- DESCRIPTION -->
    <h4 id="transport-trolley-description">Description</h4>
    <p>
      The transportTrolley is an entity able to move around the map and park or pick up the cars depending on the input it receives. <br><br>
      The customer provided us a software, named basicrobot, <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/main/it.unibo.qak21.basicrobot/userDocs/basicrobot2021.html">documented here</a> that is able to move a DDR Robot (both virtual in the WEnv or real) via commands like move forward, move backward, turn left, turn right. Note that the basicrobot is an entity working in its own computational node and in its own context namend <b>ctxbasicrobot</b>. Moreover the customer provided us a software, named planner, <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/main/it.unibo.planner20/userDocs/LabPlanner.html">documented here</a> that is able to compute a path from the position of the robot to another destination in the map. <br><br>
    </p>
    <h4 id="transport-trolley-domain-logic">About the domain logic</h4>
    <p>
      The domain logic regarding the transport trolley is to dissecting a main command (car park, car pick up, back to home) in a series of commands to be sent to the basic robot. What it could be done will be considered in the first sprint and for that reason in the first model (output of this first analysis) the transport trolley will be a mocked one.
      <br><br>
      When a car park request should be handled, the business logic has to:
      <ol>
        <li>
          Consult the planner in order to get a path to reach the INDOOR
        </li>
        <li>
          Send commands to the basic robot in order to reach the INDOOR accordingly with the path generated by the planner
        </li>
        <li>
          Take over the car on the transport trolley
        </li>
        <li>
          Consult the planner in order to get a path to reach the SLOTNUM
        </li>
        <li>
          Send commands to the basic robot in order to reach the SLOTNUM accordingly with the path generated by the planner
        </li>
        <li>
          Release the car in the SLOTNUM position.
        </li>
      </ol>
      When a car pick up request should be handled, the business logic has to:
      <ol>
        <li>
          Consult the planner in order to get a path to reach the SLOTNUM
        </li>
        <li>
          Send commands to the basic robot in order to reach the SLOTNUM accordingly with the path generated by the planner
        </li>
        <li>
          Take over the car on the transport trolley
        </li>
        <li>
          Consult the planner in order to get a path to reach the OUTDOOR
        </li>
        <li>
          Send commands to the basic robot in order to reach the OUTDOOR accordingly with the path generated by the planner
        </li>
        <li>
          Release the car in the OUTDOOR AREA.
        </li>
      </ol>
      Regarding the back to home task (mainly intendend to be started when there are not pending requests for the transport trolley), the business logic has to:
      <ol>
        <li>
          Consult the planner in order to get a path to reach the HOME
        </li>
        <li>
          Send commands to the basic robot in order to reach the HOME accordingly with the path generated by the planner
        </li>
      </ol>
      <br><br>
      Note that the basic robot that the customes gives to us has not any API to take over or release a car, so these operations will be mocked in our final deployment. However, we should take these operations in consideration in order to let the customer easily add them when it would move from a mocked prototype to a real world scenario.
      <br><br>
      Moreover the business logic must also be able to start/stop the transport trolley when the manager send a command in that sense: as analysts we want to emphasize that it is really preferrable to stop the transport trolley also during a task and not only when the task (like car park) is finished because the temperature in the parking area is in some way related to the usage of the transport trolley and the manager wants to stop the transport trolley when the temperature in the parking area is high.
      <br><br>
      We will discuss in the first sprint in more detail about the transition, using the planner, from a transport trolley task (like park this car at SLOTNUM 5) to the correspondent moves sent to the basicrobot.
    </p>
    <!-- INTERACTIONS -->
    <div width="100%" >
      <h4 id="transport-trolley-interactions">Interactions</h4>
      <!-- interaction image -->
      <div class="interactions__image">
        <center>
          <img src="./img/basic_robot_interaction.png" alt="basic_robot_interaction.png"/>
        </center>
      </div>
      <!-- interaction messages -->
      <table class="table_interactions_messages">
        <tr>
          <th>Message</th>
          <th>Payload</th>
          <th>Semantic</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>
            cmd
          </td>
          <td>
            MOVE
          </td>
          <td>
            dispatch
          </td>
          <td>
            Moves to perform until a prefixed time limit is reached or an end is received.
          </td>
        </tr>
        <tr>
          <td>
            end
          </td>
          <td>
            ARG
          </td>
          <td>
            reply
          </td>
          <td>
            Stop the current move
          </td>
        </tr>
        <tr>
          <td>
            step
          </td>
          <td>
            TIME
          </td>
          <td>
            request
          </td>
          <td>
            Move forward for the given TIME.
          </td>
        </tr>
        <tr>
          <td>
            stepdone
          </td>
          <td>
            V
          </td>
          <td>
            reply
          </td>
          <td>
            Step move completed with success.
          </td>
        </tr>
        <tr>
          <td>
            stepfail
          </td>
          <td>
            DURATION,CAUSE
          </td>
          <td>
            reply
          </td>
          <td>
            Step move cannot be completed due to some error (i.e. hitted an obstacle).
          </td>
        </tr>
      </table>
    </div>
  </div> <!-- end component -->

  <div class="component" id="park-service-gui">
    <h3>Park Service GUI</h3>
    <!-- DESCRIPTION -->
    <h4 id="park-service-gui-description">Description</h4>
    <p>
      The ParkServiceGUI is the interface provided by the ParkManagerService that is the basis of the interaction with every possible park service client.
      It allows the customer to notify to the ParkManagerService the interest in parking and, consequently, picking up the car. <br><br>
      Note that the ParkServiceGUI is a WEB interface and for that reason should carefully designed keeping in mind user experience and security issues.
      <br><br>
    </p>

    <!-- INTERACTIONS -->
    <div width="100%" >
      <h4 id="park-service-gui-interactions">Interactions</h4>
      <!-- interaction image -->
      <div class="interactions__image">
        <center>
          <img src="./img/park_service_gui_interaction.png" alt="park_service_gui_interaction.png"/>
        </center>
      </div>
      <!-- interaction messages -->
      <table class="table_interactions_messages">
        <tr>
          <th>Message</th>
          <th>Payload</th>
          <th>Semantic</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>
            parking_car_interest
          </td>
          <td>
            X
          </td>
          <td>
            request
          </td>
          <td>
            The client has notified to the ParkManagerService the interest in parking his car. The ParkServiceGUI forward this request to the central system.
          </td>
        </tr>
        <tr>
          <td>
            inform_in
          </td>
          <td>
            SLOTNUM
          </td>
          <td>
            response
          </td>
          <td>
            The central system, after checking if the indoor-area is free and there are free parking slots, accepts the client request sending to the GUI, and therefore to the client, the SLOTNUM.
          </td>
        </tr>
        <tr>
          <td>
            car_enter
          </td>
          <td>
            SLOTNUM
          </td>
          <td>
            request
          </td>
          <td>
            The client has moved his car in front to the INDOOR and pressed the CARENTER button on the ParkServiceGUI. The GUI forward the request to the central system, sending also the SLOTNUM of the client
          </td>
        </tr>
        <tr>
          <td>
            response_car_enter
          </td>
          <td>
            TOKENID
          </td>
          <td>
            response
          </td>
          <td>
            The central system has sent the transportTrolley to take over the car from the indoor and move it to the correct parking slot. Meanwhile the central system send to the client, through the GUI, a receipt that includes a unique TOKENID, to be used in the car pick up phase.
          </td>
        </tr>
        <tr>
          <td>
            car_pickup
          </td>
          <td>
            TOKENID
          </td>
          <td>
            request
          </td>
          <td>
            The client wants to pick up his car, so he submits a request by sending, via the ParkServiceGUI, the TOKENID previously received. The Gui forward the request to the central system.
          </td>
        </tr>
        <tr>
          <td>
            accept_out_success
          </td>
          <td>
            X
          </td>
          <td>
            response
          </td>
          <td>
             The given TOKENID is valid, so the central system tells the transportTrolley to pick up the right car. When the pick up phase is over, the central system tells the ParkServiceGUI that the car is ready.
          </td>
        </tr>
        <tr>
          <td>
            accept_out_failure
          </td>
          <td>
            X
          </td>
          <td>
            response
          </td>
          <td>
            The given TOKENID is invalid, so the central system tells the ParkServiceGUI that the car cannot be picked up.
          </td>
        </tr>
      </table>
    </div>
  </div> <!-- end component -->

  <div class="component" id="park-service-status-gui">
    <h3 id="park-service-status-gui-description">ParkServiceStatusGUI</h3>
    <!-- DESCRIPTION -->
    <h4>Description</h4>
    <p>
      The ParkServiceStatusGUI is used by the parking manager to administer the ParkManagerService. In particular, the ParkManagerService must be able to inform the parking-manager, through the ParkServiceStatusGUI, regarding the status of some components within the parking-area.
      Furthermore, the manager, using the ParkServiceStatusGUI, must be able to perform operations such as turning the fan on/off, setting the fan in automatic/manual mode, turning the transportTrolley on/off. <br>
      The status of the business logic is observed by the ParkServiceStatusGUI in order to be informed any time a change occurs.<br> The status must contains:
      <ul>
        <li>the availability of parking slots;</li>
        <li>the indoor-area and outdoor-area state (free/occupied);</li>
        <li>the value TA of the temperature measured by the thermometer and if it is greater than TMAX;</li>
        <li>the state of the fan (on/off, manual/automatic);</li>
        <li>the state of the transport trolley (idle, working, stopped);</li>
        <li>the alarm on DTFREE time limit.</li>
      </ul>
      The status can also contain:
      <ul>
        <li>the weight measured by the weight-sensor</li>
        <li>the distance measured by the out-sonar</li>
      </ul>  <br><br>
      Note that the ParkServiceGUI is a WEB interface and for that reason should carefully designed keeping in mind user experience and security issues.
    </p>
    <!-- INTERACTIONS -->
    <div width="100%" >
      <h4 id="park-service-status-gui-interactions">Interactions</h4>
      <!-- interaction image -->
      <div class="interactions__image">
        <center>
          <img src="./img/park_service_status_gui_interaction.png" alt="park_service_status_gui_interaction.png"/>
        </center>
      </div>
      <!-- interaction messages -->
      <table class="table_interactions_messages">
        <tr>
          <th>Message</th>
          <th>Payload</th>
          <th>Semantic</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>
            manager_fan_on
          </td>
          <td>
            X
          </td>
          <td>
            request
          </td>
          <td>
            The parking-manager wants to turn on the fan.
          </td>
        </tr>
        <tr>
          <td>
            manager_fan_off
          </td>
          <td>
            X
          </td>
          <td>
            request
          </td>
          <td>
            The parking-manager wants to turn off the fan.
          </td>
        </tr>
        <tr>
          <td>
            fan_done
          </td>
          <td>
            X
          </td>
          <td>
            reply
          </td>
          <td>
            The fan has been started/stopped correctly.
          </td>
        </tr>
        <tr>
          <td>
            fan_fail
          </td>
          <td>
            REASON
          </td>
          <td>
            reply
          </td>
          <td>
            Cannot start/stop the fan.
          </td>
        </tr>
        <tr>
          <td>
            manager_fan_automatic_mode
          </td>
          <td>
            X
          </td>
          <td>
            dispatch
          </td>
          <td>
            The parking-manager wants to set the fan in automatic mode.
          </td>
        </tr>
        <tr>
          <td>
            manager_fan_manual_mode
          </td>
          <td>
            X
          </td>
          <td>
            dispatch
          </td>
          <td>
            The parking-manager wants to set the fan in manual mode.
          </td>
        </tr>
        <tr>
          <td>
            manager_transport_trolley_start
          </td>
          <td>
            X
          </td>
          <td>
            dispatch
          </td>
          <td>
            The parking-manager wants to start the transportTrolley.
          </td>
        </tr>
        <tr>
          <td>
            manager_transport_trolley_stop
          </td>
          <td>
            X
          </td>
          <td>
            dispatch
          </td>
          <td>
            The parking-manager wants to stop the transportTrolley.
          </td>
        </tr>
      </table>
    </div>
  </div> <!-- end component -->

  <div class="component" id="business-logic">
    <h3>Business Logic</h3>
    <!-- DESCRIPTION -->
    <h4 id="business-logic-description">Description</h4>
    <p>
      The business logic integrates all the logic of the ParkManagerService. Its main task is to let processable all the informations received by the sensors and command the actuators. Moreover it has to maintain the status of the parking slot (which ones are occupied or free) and interact with the client and the manager through the GUIs. <br>
      The business logic will be located in its own computational node working in its own context named <k>ctxbusinesslogic</k>, and will interact with the other entities in the distributed system by means of network messages.
      <br><br>
      Some thoughts about the domain logic have already been discussed in the previous sections (<a href="#weight-sensor-domain-logic">weightsensor</a>, <a href="#out-sonar-domain-logic">outsonar</a>, <a href="#thermometer-domain-logic">thermometer</a>, <a href="#fan-domain-logic">fan</a>, <a href="#transport-trolley-domain-logic">transport trolley</a> and <a href="http://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/First%20Problem%20Analysis/it.unibo.qakobserver/userDocs/Documentation.html">how the observe framework works</a>), so here we will only add new thoughts strictly related to the domain logic and not about the usage of the entities.
      <br><br>
    </p>
    <div class="in-depth-content">
      <h4>TOKENID & PARKING SLOTS</h4>
      About the <k>TOKENID</k> (generated and validated by the Business Logic) we highlight that it is required some attempt to randomize its generation in order to avoid malicious users that want to steal a car. We want also to highlight that the randomization itself is not a full safe method to counteract malicious user but at least it reduces significantly the possibility of success of a malicious user. <br>
      Moreover the TOKENID must follow this additional two requirements: it must be <k>unique</k> in the parking area in a given moment; it must be simple to insert for the user in the pick up phase.
      <br>
      In order to follow the requirements and the thought discussed above we design the TOKENID as a short string of <k>5 characters</k> in which only one character (selected randomly) can be a number and this number coincides with the SLOTNUM assigned to the car and the four other characters are randomly selected in the alphabet of uppercase and lowercase letters.
      <br>
      Is quite straightforward to say that the business logic should maintain the information about which parking slots are occupied and which are free.
      <!-- <br><br> -->
    </div>
    <br>
    <div class="in-depth-content">
      <h4>OUTDOOR AREA</h4>
      From a conceptual point of view the OUTDOOR AREA should be considered as "occupied" not only when it is physically engaged by a car, but from the moment when the business logic accepted a pick up request to the moment when the car leaves the OUTDOOR AREA.
      <br>
      Keeping that in mind, in a first analysis seems easier to handle the "car pick up requests" only when the OUTDOOR AREA is conceptually "free" and reply to the client only when it is noticed that the TOKENID is invalid or when the car has been placed in the OUTDOOR AREA.
      <br>
      Moreover, about the <k>DTFREE</k> time limit requirement, we need to start a timer when the transport trolley releases the car in the OUTDOOR AREA and stop it when the car leaves the OUTDOOR AREA. If the time limit is reached (so the car does not left yet the OUTDOOR AREA) we need to inform the manager through the ParkServiceStatusGUI: seems convenient to include in the status, <k>observed</k> by the ParkServiceStatusGUI, a flag about this alarm that will be "ON" when the alarm is fired (from when the time limit is reached until when the car leaves the OUTDOOR AREA) and "OFF" in the other moments.
      <!-- <br><br> -->
    </div>
    <br>
    <div class="in-depth-content">
      <h4>INDOOR AREA</h4>
      We can replicate the same discussion done above also for the INDOOR AREA but with some difference. In fact we should consider, from a conceptual point of view, the INDOOR AREA as "occupied" from the moment when the business logic accepted a request to enter the INDOOR AREA (so, per requirements, the client received a SLOTNUM > 0) to the moment when the car leaves the INDOOR AREA because the transport trolley taked over it in order to park it.
      <br>
      Keeping that in mind, in a first analysis seems easier to handle the "enter in INDOOR AREA requests" only when the INDOOR AREA is conceptually "free" or the parking area is full and reply to the client only in those moments.
      <br>
      A similar situation regarding the DTFREE time limit requirement, noticed by the analysts, is when a client asks to enter in the INDOOR AREA but it will never enter. For that reason the analysts want to introduce a second time, named <k>DTOCCUPIED</k>, that starts in the moment when a SLOTNUM is sent to the client and stops when the client enter the INDOOR AREA; if the timer expires than the client must re-ask a SLOTNUM in order to enter the INDOOR AREA. Note that if the timer has been expired we can consider the INDOOR AREA as conceptually "free". However, since this is not a requirement, we ask to the projectists to let this feature <b>configurable</b> in order to leave this choice to the system administrator.
    </div>
    <!-- interaction qak example -->
    <h4 id="business-logic-behavior">Behavior and machine readable model</h4>
    <p>
      For a first model we decided to design the business logic as a single main actor that handles all the incoming request from the GUIs and the updates from the sensor, with two additional actors (just for simplicity) acting as watchdogs for the DTFREE timer and DTOCCUPIED timer. <k>However note that this model is just an example and very likely it will be reviewed from sprint to sprint...</k>
    </p>
    <pre>
/**
 * ==================================
 * ================================== | CLIENT ASKS TO ENTER IN INDOOR AREA
 * ==================================
 * client using parkservicegui        | request parking_car_interest(X) to businesslogic
 * businesslogic                      | when INDOOR AREA is FREE do
 *                                    |      if PARKING AREA is FULL then
 *                                    |         replyTo parking_car_interest with inform_in(0)
 *                                    |      else
 *                                    |         -- reserve the access to the INDOOR AREA for the current client --
 *                                    |         -- extract a free SLOTNUM, rename it as RESERVED_SLOTNUM_INDOOR_AREA --
 *                                    |         replyTo parking_car_interest with inform_in(RESERVED_SLOTNUM_INDOOR_AREA)
 *                                    |         forward start_watchdog(X) to dtoccupiedwatchdog
 *                                    |         -- set dtoccupiedwatchog RUNNING --
 *
 * ==================================
 * ================================== | CAR ENTER IN THE INDOOR AREA
 * ==================================
 * businesslogic                      | -- set the INDOOR AREA as OCCUPIED --
 *                                    | if dtoccupiedwatchdog is RUNNING then
 *                                    |      forward stop_watchdog(X) to dtoccupiedwatchdog
 *                                    |
 *
 *
 * ==================================
 * ================================== | DTOCCUPIED TIMEOUT
 * ==================================
 * dtoccupiedwatchdog                 | emit local_timeout(X)
 * businesslogic                      | -- do not consider anymore the indoor area as "reserved" --
 *                                    | -- set dtoccupiedwatchog NOT RUNNING --
 *
 * ==================================
 * ================================== | CLIENT ASKS TO ENTER IN THE PARKING AREA (CAR ENTER)
 * ==================================
 * client using parkservicegui        | request car_enter(SLOTNUM) to businesslogic
 * businesslogic                      | when INDOOR AREA is OCCUPIED and transport trolley IS NOT STOPPED do
 *                                    |      if SLOTNUM != 0 AND SLOTNUM == RESERVED_SLOTNUM_INDOOR_AREA then
 *                                    |         -- rename RESERVED_SLOTNUM_INDOOR_AREA into RESERVED_SLOTNUM_CAR_PARK
 *                                    |         -- move the transport trolley at the INDOOR --
 *                                    |         -- generate a random TOKENID --
 *                                    |         -- insert the TOKENID into the listOfTokenIds --
 *                                    |         replyTo car_enter with response_car_enter(TOKENID)
 *                                    |         -- take over the car on the transport trolley and park it at RESERVED_SLOTNUM_CAR_PARK --
 *                                    |         -- set SLOTNUM as OCCUPIED --
 *                                    |         -- transport trolley back to home (just for first model simplicity)
 *                                    |      else
 *                                    |         replyTo car_enter with response_car_enter(INVALID)
 *
 * ==================================
 * ================================== | CAR EXIT FROM THE INDOOR AREA
 * ==================================
 * businesslogic                      | -- set the INDOOR AREA as FREE --
 *
 * ==================================
 * ================================== | CLIENT ASKS TO PICK UP THE CAR
 * ==================================
 * client using parkservicegui        | request car_pickup(TOKENID) to businesslogic
 * businesslogic                      | when OUTDOOR AREA is FREE AND transport trolley IS NOT STOPPED do
 *                                    |      if listOfTokenIds CONTAINS TOKENID then
 *                                    |         -- infer the SLOTNUM from the TOKENID --
 *                                    |         -- move the transport trolley at SLOTNUM --
 *                                    |         -- take over the car and release it at OUTDOOR --
 *                                    |         -- set SLOTNUM as FREE --
 *                                    |         replyTo car_pickup with accept_out_success(X)
 *                                    |         forward start_watchdog(X) to dtfreewatchdog
 *                                    |         -- set dtfreewatchog RUNNING --
 *                                    |      else
 *                                    |         replyTo car_pickup with accept_out_failure(X)
 *
 * ==================================
 * ================================== | CAR EXIT FROM THE OUTDOOR AREA
 * ==================================
 * businesslogic                      | -- set the OUTDOOR AREA as FREE --
 *                                    | if dtfreewatchdog is RUNNING then
 *                                    |      forward stop_watchdog(X) to dtfreewatchdog
 *                                    |      -- set dtfreewatchdog NOT RUNNING --
 *
 *
 * ==================================
 * ================================== | DTFREE TIMEOUT
 * ==================================
 * dtoccupiedwatchdog                 | emit local_timeout(X)
 * businesslogic                      | -- inform manager about DTFREE alarm (via observable status update) --
 *                                    | -- do not consider the dtoccupiedwatchdog as "running"
 *
 * ==================================
 * ================================== | MANAGER STARTS TRANSPORT TROLLEY
 * ==================================
 * manager using parkservicestatusgui | forward manager_transport_trolley_start(X) to businesslogic
 * businesslogic                      | -- resume the transport trolley --
 *
 * ==================================
 * ================================== | MANAGER STOPS TRANSPORT TROLLEY
 * ==================================
 * manager using parkservicestatusgui | forward manager_transport_trolley_stop(X) to businesslogic
 * businesslogic                      | -- stop the transport trolley --
 *
 * ==================================
 * ================================== | MANAGER SET FAN MANUAL MODE
 * ==================================
 * manager using parkservicestatusgui | request manager_fan_manual_mode(X) to businesslogic
 * businesslogic                      | -- set fan to manual mode --
 *
 * ==================================
 * ================================== | MANAGER SET FAN AUTOMATIC MODE
 * ==================================
 * manager using parkservicestatusgui | request manager_fan_automatic_mode(X) to businesslogic
 * businesslogic                      | -- set fan to automatic mode --
 *                                    | if LOGICAL_TEMPERATURE IS LOW AND fan IS ON then
 *                                         request fan_off(X) to fan
 * fan                                |    replyTo fan_off with fan_done(X)/fan_fail(REASON)
 * businesslogic                      | else if LOGICAL_TEMPERATURE IS HIGH AND fan IS OFF then
 *                                    |    request fan_on(X) to fan
 * fan                                |    replyTo fan_on with fan_done(X)/fan_fail(REASON)
 *
 * ================================== | -- when logical temperature switches from LOW to HIGH --
 * businesslogic                      | request fan_on(X) to fan
 * fan                                | replyTo fan_on with fan_done(X)/fan_fail(REASON)
 *
 * ================================== | -- when logical temperature switches from HIGH to LOW --
 * businesslogic                      | request fan_off(X) to fan
 * fan                                | replyTo fan_off with fan_done(X)/fan_fail(REASON)
 *
 * ==================================
 * ================================== | MANAGER STARTS THE FAN
 * ==================================
 * manager using parkservicestatusgui | request manager_fan_on(X) to businesslogic
 * businesslogic                      | request fan_on(X) to fan
 * fan                                | replyTo fan_on with fan_done(X)/fan_fail(REASON)
 * businesslogic                      | replyTo manager_fan_on with fan_done(X)/fan_fail(REASON)
 *
 * ==================================
 * ================================== | MANAGER STOPS THE FAN
 * ==================================
 * manager using parkservicestatusgui | request manager_fan_off(X) to businesslogic
 * businesslogic                      | request fan_off(X) to fan
 * fan                                | replyTo fan_off with fan_done(X)/fan_fail(REASON)
 * businesslogic                      | replyTo manager_fan_off with fan_done(X)/fan_fail(REASON)
 *
 */
    </pre>
    <div class="interaction_qak_example">
      <h4 id="business-logic-qak">QAK Model</h4>
      <p>
        The following QAK is a mock implementation of what we discussed above, its intent is to show how the Business Logic could be implemented using the QAK meta-model.
        However, there are some simplification we made and they are listed below.
        <ol>
          <li>
            The TOKENID is not generated randomly, it always appends the SLOTNUM at a fixed prefix.
          </li>
        </ol>
      </p>
      <a href="../it.unibo.first_problem_analysis.businesslogic/src/businesslogic.qak">
        <div class="interaction_qak_example_link">
          business logic.qak
        </div>
      </a>
    </div>
  </div> <!-- end component -->

  <div class="problems_and_relevant_aspects" id="problems-relevant-aspects">
    <h3>Possible problems and relevant aspects</h3>
    <p>
      During this analysis, some problematic aspects have been noticed:
      <ul>
        <li>the clients of the parking-area may do something unpredictable and dangerous that may have negative effects on the system's behaviour. An example of this is the client that brings his car to the indoor-area but does not press the car enter button. For this specific situation a timer between the informIn and the carEnter phases may be useful. Another example is the client that stays in the car while the transport trolley moves it inside the parking-area. Such situations are not noticeable by the system, at least not with the current sensors made available by the customer.</li>
        <li>Make the system components "technology independent". Since we are working in a virtual environment and with virtual components, this should be done with a fair amount of abstraction that insures that the replacement of simulated components with the real ones does not affect the business logic.</li>
        <li>In case of faults, some of the data kept by the business logic, in general the state of the system, must survive if the system is restarted. How to make this information persistent should be considered in the following sprints. Also, faults in one of the components may render the system unusable.</li>
      </ul>
    </p>
  </div><!--  end problems and relevant aspects -->

  <div class="logical_architecture" id="logical-architecture">
    <h3>Logical Architecture</h3>
    <p align="center"><a href="#legenda">Legenda</a></p>
    <div class="interactions__image">
      <center>
        <img src="./img/logical_architecture.png" alt="logical_architecture.png"/>
      </center>
    </div>
    <div class="interaction_qak_example" style="width:90%;">
      <h4>QAK Model</h4>
      <p>
        The purpose of this model is to show the sequence of interactions between a client and the business logic in order to park a car and then pick up it.
      </p>
      <a href="../it.unibo.first_problem_analysis.mastermind/src/mastermind.qak">
        <div class="interaction_qak_example_link">
          first executable model.qak
        </div>
      </a>
      <h4>How to run</h4>
      <p>
        <ol>
          <li>
            Open a terminal inside the "First Problem Analysis" directory
          </li>
          <li>
            Build all the libraries with:
            <pre>[WINDOWS] .\rebuild_for_docker.bat</pre>
            or
            <pre>[LINUX]   ./rebuild_for_docker.bash</pre>
          </li>
          <li>
            Build the docker images with:
            <pre>docker-compose -f firstproblemanalysis.yaml build</pre>
          </li>
          <li>
            Launch the docker images with:
            <pre>docker-compose -f firstproblemanalysis.yaml up</pre>
          </li>
          <li>
            Wait until all the docker images are running...
          </li>
          <li>
            Open a new windows terminal inside the "it.unibo.first_problem_analysis.mastermind" directory
          </li>
          <li>
            Launch the "first executable model" with:
            <pre>gradle -b build_ctxmastermind.gradle run</pre>
          </li>
        </ol>
      </p>
    </div>
  </div>

</div>  <!-- End Problem Analysis class remark -->

<h2 id="test-plan">Test Plan</h2>
<div class="remark">
  <p>
    Below are listed some possible tests for a subset of the system's functionalities.
    <br>
    Few helper classes have been defined to simplify the tests development: <a href="../it.unibo.first_problem_analysis.testable_model/test/it/unibo/qakutils/CoapQAK.kt">CoapQAK.kt</a>,
    <a href="../it.unibo.first_problem_analysis.testable_model/test/it/unibo/qakutils/Message.kt">Message.kt</a>.
  </p>
  <h4>TestSuccessAcceptIn</h4>
  <ul>
    <li>
      <b>Description</b>: The client asks to enter in the indoor area and receives a valid SLOTNUM.
    </li>
    <li>
      <b>Initial conditions</b>:
      <ol>
        <li>
          Empty indoor area.
        </li>
        <li>
          At least one free parking-slot.
        </li>
        <li>
          The transportTrolley is not stopped.
        </li>
      </ol>
    </li>
    <li>
      <b>Expectations</b>:
      <ol>
        <li>
          The ParkServiceGUI shows a SLOTNUM with a value > 0.
        </li>
      </ol>
    </li>
    <li>
      <b>Tested requirements</b>: F1, F2, F3
    </li>
  </ul>
  <h4>TestFullParkingArea</h4>
  <ul>
    <li>
      <b>Description</b>: The client asks to enter in the indoor area but he is refused and receives a SLOTNUM = 0.
    </li>
    <li>
      <b>Initial conditions</b>:
      <ol>
        <li>
          No free parking-slots available.
        </li>
        <li>
          The transportTrolley is not stopped.
        </li>
      </ol>
    </li>
    <li>
      <b>Expectations</b>:
      <ol>
        <li>
          The ParkServiceGUI shows a SLOTNUM with a value = 0.
        </li>
      </ol>
    </li>
    <li>
      <b>Tested requirements</b>: F1, F2, F3
    </li>
  </ul>
  <h4>TestTripOneCar</h4>
  <ul>
    <li>
      <b>Description</b>: A car enter in the parking-area and then exit from the parking-area.
    </li>
    <li>
      <b>Initial conditions</b>:
      <ol>
        <li>
          Empty indoor-area
        </li>
        <li>
          At least one parking-slot free.
        </li>
        <li>
          Empty outdoor-area.
        </li>
        <li>
          The transportTrolley is not stopped.
        </li>
      </ol>
    </li>
    <li>
      <b>Expectations</b>:
      <ol>
        <li>
          The car enter in the parking-area.
        </li>
        <li>
          On pick up phase the TOKENID is valid and the car exits from the parking-area.
        </li>
      </ol>
    </li>
    <li>
      <b>Tested requirements</b>: F1, F2, F3, F4, F5, F6, F7, F8, F9, F16, F17, F20, F21
    </li>
  </ul>
  <h4>TestInvalidTokenId</h4>
  <ul>
    <li>
      <b>Description</b>: The client when asks to pick up the car receives an error due to an invalid TOKENID has been inserted.
    </li>
    <li>
      <b>Initial conditions</b>:
      <ol>
        <li>
          The client has previously parked a car in the parking-area. However it is not strictly necessary to test a refusal of an invalid token.
        </li>
      </ol>
    </li>
    <li>
      <b>Expectations</b>:
      <ol>
        <li>
          The TOKENID inserted by the client is not valid. The ParkServiceGUI shows to the client an error.
        </li>
      </ol>
    </li>
    <li>
      <b>Tested requirements</b>: F6, F7, F8, F9
    </li>
  </ul>
  <h4>TestOccupiedIndoorArea</h4>
  <ul>
    <li>
      <b>Description</b>: The client waits for a reasonable amount of time a response from the ParkServiceGUI in order to enter the indoor area. This response does not arrive.
    </li>
    <li>
      <b>Initial conditions</b>:
      <ol>
        <li>
          The indoor area is occupied.
        </li>
        <li>
          The transportTrolley is not stopped.
        </li>
      </ol>
    </li>
    <li>
      <b>Expectations</b>:
      <ol>
        <li>
          The client does not receive a response in 15 seconds.
        </li>
      </ol>
    </li>
    <li>
      <b>Tested requirements</b>: F1, F2, F16
    </li>
  </ul>
  <h4>TestOccupiedOutdoorArea</h4>
  <ul>
    <li>
      <b>Description</b>: The client waits for a reasonable amount of time a response from the ParkServiceGUI in order to pick up the car. This response does not arrive.
    </li>
    <li>
      <b>Initial conditions</b>:
      <ol>
        <li>
          The outdoor area is occupied.
        </li>
        <li>
          The transportTrolley is not stopped.
        </li>
        <li>
          The transportTrolley is not serving other requests.
        </li>
        <li>
          DTFREE alarm and car removal from the outdoor area requirement, as done in the other tests, is disabled for this test.
        </li>
      </ol>
    </li>
    <li>
      <b>Expectations</b>:
      <ol>
        <li>
          The client does not receive a response in 15 seconds.
        </li>
      </ol>
    </li>
    <li>
      <b>Tested requirements</b>: F6, F7, F17
    </li>
  </ul>
  <h4>TestTransportTrolleyBackToHome</h4>
  <ul>
    <li>
      <b>Description</b>: The transportTrolley comes back to HOME some time after it has handled a parking/pick up car request.
    </li>
    <li>
      <b>Initial conditions</b>:
      <ol>
        <li>
          The transportTrolley is not stopped.
        </li>
        <li>
          The transportTrolley is handling a parking/pick up car request.
        </li>
      </ol>
    </li>
    <li>
      <b>Expectations</b>:
      <ol>
        <li>
          By observing the BusinessLogic is noticed the status of the TransportTrolley becomes IDLE.
        </li>
      </ol>
    </li>
    <li>
      <b>Tested requirements</b>: F22
    </li>
  </ul>
  <h4>TestWeightSensorDetectCar</h4>
  <ul>
    <li>
      <b>Description</b>: The weightSensor is able to detect when a car enter the indoor area.
    </li>
    <li>
      <b>Initial conditions</b>:
      <ol>
        <li>
          The indoor area is free.
        </li>
        <li>
          The weightSensor is not detecting a car in the indoor area.
        </li>
      </ol>
    </li>
    <li>
      <b>Expectations</b>:
      <ol>
        <li>
          By observing the BusinessLogic is noticed that the indoor area becomes occupied.
        </li>
      </ol>
    </li>
    <li>
      <b>Tested requirements</b>: F16
    </li>
  </ul>
  <h4>TestWeightSensorCarNotDetected</h4>
  <ul>
    <li>
      <b>Description</b>: The weightSensor is able to detect when a car exits the indoor area.
    </li>
    <li>
      <b>Initial conditions</b>:
      <ol>
        <li>
          The indoor area is occupied.
        </li>
        <li>
          The weightSensor is detecting a car in the indoor area.
        </li>
      </ol>
    </li>
    <li>
      <b>Expectations</b>:
      <ol>
        <li>
          By observing the BusinessLogic is noticed that the indoor area becomes free.
        </li>
      </ol>
    </li>
    <li>
      <b>Tested requirements</b>: F16
    </li>
  </ul>
  <h4>TestSonarDetectCar</h4>
  <ul>
    <li>
      <b>Description</b>: The outSonar is able to detect when a car enter the outdoor area.
    </li>
    <li>
      <b>Initial conditions</b>:
      <ol>
        <li>
          The outdoor area is free.
        </li>
        <li>
          The outSonar is not detecting a car in the indoor area.
        </li>
      </ol>
    </li>
    <li>
      <b>Expectations</b>:
      <ol>
        <li>
          By observing the BusinessLogic is noticed that the outdoor area becomes occupied.
        </li>
      </ol>
    </li>
    <li>
      <b>Tested requirements</b>: F17
    </li>
  </ul>
  <h4>TestSonarCarNotDetected</h4>
  <ul>
    <li>
      <b>Description</b>: The outSonar is able to detect when a car exits the outdoor area.
    </li>
    <li>
      <b>Initial conditions</b>:
      <ol>
        <li>
          The outdoor area is occupied.
        </li>
        <li>
          The outSonar is detecting a car in the indoor area.
        </li>
      </ol>
    </li>
    <li>
      <b>Expectations</b>:
      <ol>
        <li>
          By observing the BusinessLogic is noticed that the outdoor area becomes free.
        </li>
      </ol>
    </li>
    <li>
      <b>Tested requirements</b>: F17
    </li>
  </ul>
  <h4>TestThermometerTemperatureHigh</h4>
  <ul>
    <li>
      <b>Description</b>: The logical thermometer is able to switch the logical temperature state from LOW to HIGH when the temperature becomes greater than TMAX.
    </li>
    <li>
      <b>Initial conditions</b>:
      <ol>
        <li>
          The temperature measured by the physical thermometer is lower than or equal to TMAX.
        </li>
        <li>
          The logical temperature measured by the logical thermometer is LOW.
        </li>
      </ol>
    </li>
    <li>
      <b>Expectations</b>:
      <ol>
        <li>
          By observing the BusinessLogic is noticed that the logical temperature becomes high.
        </li>
      </ol>
    </li>
    <li>
      <b>Tested requirements</b>: F19
    </li>
  </ul>
  <h4>TestThermometerTemperatureLow</h4>
  <ul>
    <li>
      <b>Description</b>: The logical thermometer is able to switch the logical temperature state from HIGH to LOW when the temperature becomes lower than or equal to TMAX.
    </li>
    <li>
      <b>Initial conditions</b>:
      <ol>
        <li>
          The temperature measured by the physical thermometer is greater than TMAX.
        </li>
        <li>
          The logical temperature measured by the logical temperature is HIGH.
        </li>
      </ol>
    </li>
    <li>
      <b>Expectations</b>:
      <ol>
        <li>
          By observing the BusinessLogic is noticed that the logical temperature is LOW.
        </li>
      </ol>
    </li>
    <li>
      <b>Tested requirements</b>: F19
    </li>
  </ul>
  <h4>TestParkServiceStatusGuiSetFanManualMode</h4>
  <ul>
    <li>
      <b>Description</b>: After setting the fan in manual mode the manager starts and stops the fan.
    </li>
    <li>
      <b>Initial conditions</b>:
      <ol>
        <li>
          The fan is in automatic mode.
        </li>
        <li>
          The fan is OFF.
        </li>
      </ol>
    </li>
    <li>
      <b>Expectations</b>:
      <ol>
        <li>
          By observing the BusinessLogic is noticed that the fan switches to manual mode after the manager's input.
        </li>
        <li>
          By observing the BusinessLogic is noticed that the fan switches to ON status after the manager's input.
        </li>
        <li>
          By observing the BusinessLogic is noticed that the fan switches to OFF status after the manager's input.
        </li>
      </ol>
    </li>
    <li>
      <b>Tested requirements</b>: F10, F12, F13
    </li>
  </ul>
  <h4>TestParkServiceStatusGuiSetFanAutomaticMode</h4>
  <ul>
    <li>
      <b>Description</b>: After setting the fan in automatic mode the fan switch its status between ON and OFF depending on the logical temperature measured by the thermometer in the parking-area.
    </li>
    <li>
      <b>Initial conditions</b>:
      <ol>
        <li>
          The fan is in manual mode.
        </li>
        <li>
          The fan is OFF.
        </li>
      </ol>
    </li>
    <li>
      <b>Expectations</b>:
      <ol>
        <li>
          By observing the BusinessLogic is noticed that the fan switches to automatic mode after the manager's input.
        </li>
        <li>
          By observing the BusinessLogic is noticed that the fan switches to ON status after the temperature becomes greater than TMAX.
        </li>
        <li>
          By observing the BusinessLogic is noticed that the fan switches to OFF status after the temperature becomes lower than or equal to TMAX.
        </li>
      </ol>
    </li>
    <li>
      <b>Tested requirements</b>: F10, F12, F13
    </li>
  </ul>
  <h4>TestParkServiceStatusGuiResumeTransportTrolley</h4>
  <ul>
    <li>
      <b>Description</b>: As a manager start and stop the transport trolley.
    </li>
    <li>
      <b>Initial conditions</b>:
      <ol>
        <li>
          The transport trolley is not stopped.
        </li>
      </ol>
    </li>
    <li>
      <b>Expectations</b>:
      <ol>
        <li>
          By observing the BusinessLogic is noticed that the transport trolley is stopped after the stop command and is not stopped after the start command.
        </li>
      </ol>
    </li>
    <li>
      <b>Tested requirements</b>: F11
    </li>
  </ul>
  <h4>TestDtfreeAlarm</h4>
  <ul>
    <li>
      <b>Description</b>: Check if the manager receives the alarm when a car stays in the outdoor area for more time than the DTFREE time limit.
    </li>
    <li>
      <b>Initial conditions</b>:
      <ol>
        <li>
          The outdoor area is free.
        </li>
      </ol>
    </li>
    <li>
      <b>Expectations</b>:
      <ol>
        <li>
          After a car pick up request the car remains enough time in the outdoor area in order to receive the outdoor alarm within the business logic status.
        </li>
      </ol>
    </li>
    <li>
      <b>Tested requirements</b>: F15
    </li>
  </ul>


  <h4>Test files</h4>
  <table width="100%" style="border:none;">
    <tr>
      <td style="border:none;">
        <div class="interaction_qak_example" style="width:90%;">
          <h4>App Test</h4>
          <p></p>
          <a href="../it.unibo.first_problem_analysis.testable_model/test/it/unibo/first_problem_analysis/test/TestPlan.kt">
            <div class="interaction_qak_example_link">
              Test Plan.kt
            </div>
          </a>
        </div>
      </td>
    </tr>
  </table>
  <h4>How to run</h4>
  <p>
    <ol>
      <li>
        Open a terminal inside the "First Problem Analysis" directory
      </li>
      <li>
        Build all the libraries with:
        <pre>[WINDOWS] .\rebuild_for_docker.bat</pre>
        or
        <pre>[LINUX]   ./rebuild_for_docker.bash</pre>
      </li>
      <li>
        Build the docker images with:
        <pre>docker-compose -f firstproblemanalysis.yaml build</pre>
      </li>
      <li>
        Launch the docker images with:
        <pre>docker-compose -f firstproblemanalysis.yaml up</pre>
      </li>
      <li>
        Wait until all the docker images are running...
      </li>
      <li>
        Open a new windows terminal inside the "it.unibo.first_problem_analysis.testable_model" directory
      </li>
      <li>
        Launch the tests with:
        <pre>gradle test</pre>
      </li>
    </ol>
  </p>

</div><!-- End Test Plan class remark -->


<h2 id="work-plan">Workplan</h2>
<div class="remark workplan">
  <p>
    Based on what was discussed in this initial phase, we concluded that there will be needed 5 sprints to finish this application.
  </p>
  <h3><b>Sprint 1 - TransportTrolley</b> (24 hours)</h3>
  <table>
    <tr>
      <th></th>
      <th>
        Sprint backlog
      </th>
      <th>
        Requirements
      </th>
      <th>
        Working time
      </th>
    </tr>
    <tr>
      <td>
        Planner
      </td>
      <td>
        The transportTrolley, given a task, is able to reach the right cell in the parking-area and perform its job.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F20">F20</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F21">F21</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F22">F22</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F23">F23</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#NF2">NF2</a>
      </td>
      <td>
        12h
      </td>
    </tr>
    <tr>
      <td>
        Start & Stop
      </td>
      <td>
        The transportTrolley can be started/stopped with a command.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F11">F11</a> (only start and stop)
      </td>
      <td>
        6h
      </td>
    </tr>
    <tr>
      <td>
        Persistence
      </td>
      <td>
        The status of the transportTrolley must survive after a system reboot.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#NF3">NF3</a>
      </td>
      <td>
        3h
      </td>
    </tr>
    <tr>
      <td>
        Monitoring
      </td>
      <td>
        Should be possible to analyze the behaviour of the transportTrolley.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#NF4">NF4</a>
      </td>
      <td>
        3h
      </td>
    </tr>
  </table>
  <h3><b>Sprint 2 - Car Parking</b> (38 hours)</h3>
  <table>
    <tr>
      <th></th>
      <th>
        Sprint backlog
      </th>
      <th>
        Requirements
      </th>
      <th>
        Working time
      </th>
    </tr>
    <tr>
      <td>
        WeightSensor
      </td>
      <td>
        The weightSensor is able to detect the presence of a car in the indoor area.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F16">F16</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#NF2">NF2</a>
      </td>
      <td>
        4h
      </td>
    </tr>
    <tr>
      <td>
        Parking car phase
      </td>
      <td>
        The system is able to manage a parking car request.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F1">F1</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F2">F2</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F3">F3</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F4">F4</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F5">F5</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#NF1">NF1</a>
      </td>
      <td>
        14h
      </td>
    </tr>
    <tr>
      <td>
        ParkServiceGUI
      </td>
      <td>
        The system provides the ParkServiceGUI to handle the client's car parking requests.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F1">F1</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F4">F4</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F5">F5</a>
      </td>
      <td>
        10h
      </td>
    </tr>
    <tr>
      <td>
        Persistence
      </td>
      <td>
        The status of the system must survive after a system reboot.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#NF3">NF3</a>
      </td>
      <td>
        5h
      </td>
    </tr>
    <tr>
      <td>
        Monitoring
      </td>
      <td>
        Should be possible to analyze the behaviour of the system.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#NF4">NF4</a>
      </td>
      <td>
        5h
      </td>
    </tr>
  </table>
  <h3><b>Sprint 3 - Car Pick up</b> (40 hours)</h3>
  <table>
    <tr>
      <th></th>
      <th>
        Sprint backlog
      </th>
      <th>
        Requirements
      </th>
      <th>
        Working time
      </th>
    </tr>
    <tr>
      <td>
        OutSonar
      </td>
      <td>
        The outSonar is able to detect the presence of a car in the outdoor area.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F17">F17</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#NF2">NF2</a>
      </td>
      <td>
        4h
      </td>
    </tr>
    <tr>
      <td>
        Pick up car phase
      </td>
      <td>
        The system is able to manage a pick up car request.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F6">F6</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F7">F7</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F8">F8</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F9">F9</a>
      </td>
      <td>
        14h
      </td>
    </tr>
    <tr>
      <td>
        DTFREE
      </td>
      <td>
        The system is able to notify about the DTFREE time limit in the outdoor area.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F15">F15</a> (partially)
      </td>
      <td>
        2h
      </td>
    </tr>
    <tr>
      <td>
        ParkServiceGUI
      </td>
      <td>
        The system provides the ParkServiceGUI to handle the client's car pick up requests.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F6">F6</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F9">F9</a>
      </td>
      <td>
        10h
      </td>
    </tr>
    <tr>
      <td>
        Persistence
      </td>
      <td>
        The status of the system must survive after a system reboot.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#NF3">NF3</a>
      </td>
      <td>
        5h
      </td>
    </tr>
    <tr>
      <td>
        Monitoring
      </td>
      <td>
        Should be possible to analyze the behaviour of the system.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#NF4">NF4</a>
      </td>
      <td>
        5h
      </td>
    </tr>
  </table>
  <h3><b>Sprint 4 - Parking Manager</b> (44 hours)</h3>
  <table>
    <tr>
      <th></th>
      <th>
        Sprint backlog
      </th>
      <th>
        Requirements
      </th>
      <th>
        Working time
      </th>
    </tr>
    <tr>
      <td>
        Thermometer
      </td>
      <td>
        The thermometer is able to measure the temperature inside the parking area.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F19">F19</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#NF2">NF2</a>
      </td>
      <td>
        4h
      </td>
    </tr>
    <tr>
      <td>
        Fan
      </td>
      <td>
        The system is able to manage the fan.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F12">F12</a> (partially), <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F13">F13</a> (partially), <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F14">F14</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#NF2">NF2</a>
      </td>
      <td>
        6h
      </td>
    </tr>
    <tr>
      <td>
        Parking area status
      </td>
      <td>
        The parking area status is observable by the manager.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F10">F10</a> (partially)
      </td>
      <td>
        8h
      </td>
    </tr>
    <tr>
      <td>
        ParkServiceStatusGUI
      </td>
      <td>
        The system provides the ParkServiceStatusGUI to the parking manager.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F10">F10</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F11">F11</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F12">F12</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F13">F13</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F15">F15</a>
      </td>
      <td>
        14h
      </td>
    </tr>
    <tr>
      <td>
        Persistence
      </td>
      <td>
        The status of the system must survive after a system reboot.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#NF3">NF3</a>
      </td>
      <td>
        6h
      </td>
    </tr>
    <tr>
      <td>
        Monitoring
      </td>
      <td>
        Should be possible to analyze the behaviour of the system.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#NF4">NF4</a>
      </td>
      <td>
        6h
      </td>
    </tr>
  </table>
  <h3><b>Sprint 5 - Real Deployment </b> (16 hours)</h3>
  <table>
    <tr>
      <th></th>
      <th>
        Sprint backlog
      </th>
      <th>
        Requirements
      </th>
      <th>
        Working time
      </th>
    </tr>
    <tr>
      <td>
        OutSonar - real device
      </td>
      <td>
        A real device is used for the OutSonar.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#F18">F18</a>, <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#NF2">NF2</a>
      </td>
      <td>
        6h
      </td>
    </tr>
    <tr>
      <td>
        Distributed System
      </td>
      <td>
        The system is deployed in a distributed environment.
      </td>
      <td>
        <a href="https://htmlpreview.github.io/?https://github.com/lorepersa/Automated-Car-Parking/blob/main/Requirements%20Analysis/Requirements%20analysis.html#NF5">NF5</a>
      </td>
      <td>
        10h
      </td>
    </tr>
  </table>
  <p>Our goal is to deliver the product to the customer by <k>April 15th</k>.</p>
</div>


<div class="contact-us" id="contact-us">
  <table>
    <tr>
      <td colspan="2"><h3>By:</h3></td>
    </tr>
    <tr>
      <td>
        <div class="student__image">
          <center>
            <img src="./img/students/lorenzo_persampieri.jpg" alt="lorenzo_persampieri.jpg"/>
          </center>
        </div>
      </td>
      <td>
        <div class="student__image">
          <center>
            <img src="./img/students/gianluca_soavi.jpg" alt="gianluca_soavi.jpg"/>
          </center>
        </div>
      </td>
    </tr>
    <tr>
      <th>Lorenzo Persampieri</th>
      <th>Gianluca Soavi</th>
    </tr>
    <tr style="padding-bottom: 10px;">
      <td>lorenzo.persampieri@studio.unibo.it</td>
      <td>gianluca.soavi@studio.unibo.it</td>
    </tr>
    <tr>
      <th colspan="2" style="border-top: 1px solid black; padding-top: 10px;">Github Repository</th>
    </tr>
    <tr>
      <td colspan="2"><a href="https://github.com/lorepersa/Automated-Car-Parking">https://github.com/lorepersa/Automated-Car-Parking</a></td>
    </tr>
  </table>
</div><!-- End Contact Us class remark -->


</body>
</html>
