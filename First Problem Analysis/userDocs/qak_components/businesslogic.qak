
System first_model

Request   parking_car_interest : parking_car_interest( X )
Reply     inform_in            : inform_in( SLOTNUM )
Request   car_enter            : car_enter( SLOTNUM )
Reply     response_car_enter   : response_car_enter( TOKENID )
Request   car_pickup           : car_pickup( TOKENID )
Reply     accept_out_success   : accept_out_success( X )
Reply     accept_out_failure   : accept_out_failure( X )
Event     status_parking_slots    : status_parking_slots(P1,P2,P3,P4,P5,P6)

Event     transport_trolley_position_indoor  : transport_trolley_position_indoor( X )
Event     transport_trolley_position_outdoor : transport_trolley_position_outdoor( X )
Event     transport_trolley_position_slotnum : transport_trolley_position_slotnum( SLOTNUM )
Event     indoor_area_occupied : indoor_area_occupied( X )
Event     indoor_area_free     : indoor_area_free( C )
Event     outdoor_area_occupied : outdoor_area_occupied( X )
Event     outdoor_area_free     : outdoor_area_free( X )
Dispatch  transport_trolley_car_park         : transport_trolley_car_park( SLOTNUM )
Dispatch  transport_trolley_car_pickup       : transport_trolley_car_pickup( SLOTNUM )
Dispatch  transport_trolley_go_home          : transport_trolley_go_home( X )


Context ctxFirstModel  ip [host="localhost" port=8053]

// NOTE: 
// The logicaltransporttrolley is not defined in this QAK demo file.
// We want just to show how the interactions discussed in the first 
// problem analysis about the business logic could be 
// modeled with the QAK meta-model.


QActor businesslogic context ctxFirstModel {
	
	[#
		var  indoor_area_free = true
		var  outdoor_area_free = true
		var parking_slots: java.util.Queue<Int> = java.util.LinkedList<Int>(listOf(1, 2, 3, 4, 5, 6))
		var STATUS_PARKING_AREA = arrayOf<String>("FREE", "FREE", "FREE", "FREE", "FREE", "FREE")
		var token_parking_slots = java.util.LinkedList<String>()
		var SLOTNUM = 0
		var RESERVED_SLOTNUM_INDOOR_AREA = 0
		var SLOTNUM_PICKUP = 0
		var TOKENID = ""
		var tokenid_valid = false
		var car_pickup_request = false
		var car_park_request = false
	#]
	
	State init initial {
		println("[businesslogic] | [State] init | Entry point.")
		[#
			indoor_area_free = true
			outdoor_area_free = true
			parking_slots = java.util.LinkedList<Int>(listOf(1, 2, 3, 4, 5, 6))
			STATUS_PARKING_AREA = arrayOf<String>("FREE", "FREE", "FREE", "FREE", "FREE", "FREE")
			token_parking_slots = java.util.LinkedList<String>()
			SLOTNUM = 0
			RESERVED_SLOTNUM_INDOOR_AREA = 0
			SLOTNUM_PICKUP = 0
			TOKENID = ""
			tokenid_valid = false
			car_pickup_request = false
			car_park_request = false
		#]
		println("[businesslogic] | [State] init | Exit point.")
	}Goto running 
	
	State running {
		println("[businesslogic] | [State] running | Entry point.")
		println("[businesslogic] | [State] running | Exit point.")
	}
	Transition t0 whenRequest   parking_car_interest and [# indoor_area_free #] -> checkCarIndoorArea
				  whenRequest   car_enter and [# !indoor_area_free && !car_park_request #] -> carEnter
				  whenEvent     transport_trolley_position_indoor and [# car_park_request #] -> sendTokenId
				  whenEvent     transport_trolley_position_slotnum and [# car_park_request #] -> carParkDone
				  whenEvent     indoor_area_free -> setFreeIndoorArea
				  whenEvent     indoor_area_occupied -> setOccupiedIndoorArea
				  whenRequest   car_pickup and [# outdoor_area_free && !car_pickup_request #] -> checkTokenId
				  whenEvent     transport_trolley_position_outdoor and [# car_pickup_request #] -> pickUpCarFinished
				  whenEvent     outdoor_area_free -> setFreeOutdoorArea
				  whenEvent     outdoor_area_occupied -> setOccupiedOutdoorArea
				  
	State sendTransportTrolleyBackHome {
		println("[businesslogic] | [State] sendTransportTrolleyBackHome | Entry point.")
		println("[businesslogic] | [State] sendTransportTrolleyBackHome | Sending the transport trolley back home because there are no other requests")
		forward logicaltransporttrolley -m transport_trolley_go_home : transport_trolley_go_home(ok)	
		println("[businesslogic] | [State] sendTransportTrolleyBackHome | Exit point.")
	} Goto running
	
	State checkCarIndoorArea {
		println("[businesslogic] | [State] checkCarIndoorArea | Entry point.")
		println("[businesslogic] | [State] checkCarIndoorArea | Checking if there is a parking slot free and if there is a car in the indoor area...")
		println("[businesslogic] | [State] checkCarIndoorArea | Exit point.")
	} Goto acceptIn if [# !parking_slots.isEmpty() #] else denyAcceptIn
	
	State acceptIn {
		println("[businesslogic] | [State] acceptIn | Entry point.")
		[# 
			RESERVED_SLOTNUM_INDOOR_AREA = parking_slots.poll()
			indoor_area_free = false
		#]
		println("[businesslogic] | [State] acceptIn | Car in the indoor area. I'm sending SLOTNUM.")
		//println("[central_system] | [State] acceptIn | PARKING SLOTS FREE = $parking_slots_free")
		replyTo parking_car_interest with inform_in : inform_in($RESERVED_SLOTNUM_INDOOR_AREA)
		println("[businesslogic] | [State] acceptIn | Exit point.")
	} Goto running
	
	State denyAcceptIn {
		println("[businesslogic] | [State] denyAcceptIn | Entry point.")
		println("[businesslogic] | [State] denyAcceptIn | Sending failure to client.. ")
		replyTo parking_car_interest with inform_in : inform_in(0)
		println("[businesslogic] | [State] denyAcceptIn | Exit point.")
	} Goto running
	
	State carEnter {
		println("[businesslogic] | [State] carEnter | Entry point.")
		onMsg( car_enter : car_enter(SLOTNUM) ){
			[# 
				val client_SLOTNUM = payloadArg(0).toInt()
				STATUS_PARKING_AREA[RESERVED_SLOTNUM_INDOOR_AREA - 1] = "OCCUPIED"
				car_park_request = true
			#]
			println("[businesslogic] | [State] carEnter | Received SLOTNUM=$client_SLOTNUM")
			println("[businesslogic] | [State] carEnter | Sending trolley to Indoor...")
			forward logicaltransporttrolley -m transport_trolley_car_park : transport_trolley_car_park($RESERVED_SLOTNUM_INDOOR_AREA)
		}
		println("[businesslogic] | [State] carEnter | Exit point.")
	} Goto running 
	
	State sendTokenId {
		println("[businesslogic] | [State] sendTokenId | Entry point.")
		[#
			// simplified! need to change in random generation
			TOKENID = "PMSx$RESERVED_SLOTNUM_INDOOR_AREA" 
			token_parking_slots.add(TOKENID)
		#]
		println("[businesslogic] | [State] carEnter | Created  TOKENID=$TOKENID")
		replyTo car_enter with response_car_enter : response_car_enter($TOKENID)
		println("[businesslogic] | [State] sendTokenId | Exit point.")
	} Goto running
	
	State carParkDone {
		println("[businesslogic] | [State] carParkDone | Entry point.")
		[# 
			car_park_request = false 
			val P1 =  STATUS_PARKING_AREA[0]
			val P2 =  STATUS_PARKING_AREA[1]
			val P3 =  STATUS_PARKING_AREA[2]
			val P4 =  STATUS_PARKING_AREA[3]
			val P5 =  STATUS_PARKING_AREA[4]
			val P6 =  STATUS_PARKING_AREA[5]
		#]
		emit status_parking_slots : status_parking_slots($P1, $P2, $P3, $P4, $P5, $P6)
		println("[businesslogic] | [State] carParkDone | Exit point.")
	} Goto running
	
	State setFreeIndoorArea {
		println("[businesslogic] | [State] setFreeIndoorArea | Entry point.")
		println("[businesslogic] | [State] setFreeIndoorArea | The weight sensor has notified that the car has left the parking area.")
		[# indoor_area_free = true #]
		println("[businesslogic] | [State] setFreeIndoorArea | Exit point.")
	} Goto running
	
	State setOccupiedIndoorArea {
		println("[businesslogic] | [State] setOccupiedIndoorArea | Entry point.")
		println("[businesslogic] | [State] setOccupiedIndoorArea | The weight sensor has notified that the car has entered the indoor area.")
		[# indoor_area_free = false #]
		println("[businesslogic] | [State] setOccupiedIndoorArea | Exit point.")
	} Goto running
	
	State checkTokenId {
		println("[businesslogic] | [State] checkTokenId | Entry point.")
		println("[businesslogic] | [State] checkTokenId | Checking the TokenID...")
		onMsg( car_pickup : car_pickup(TOKENID) ) {
		[# 
			tokenid_valid = false
			TOKENID = payloadArg(0).toString() 
			val token_index = token_parking_slots.indexOf(TOKENID)
		#]
			if [# token_index >= 0 #] {
				[# 
				token_parking_slots.removeAt(token_index)
				for (c in TOKENID) { #]
					if [# c.isDigit() #] {
					[# 
						tokenid_valid = true
						SLOTNUM = Character.getNumericValue(c)
					#]
					}
				[# } #]
			}
		}
		println("[businesslogic] | [State] checkTokenId | Exit point.")
	} Goto pickUpCar if [# tokenid_valid #] else invalidTokenId
	
	State invalidTokenId {
		println("[businesslogic] | [State] invalidTokenId | Entry point.")
		println("[businesslogic] | [State] invalidTokenId | TOKENID=$TOKENID is invalid. Can't pick up the car.")
		replyTo car_pickup with accept_out_failure : accept_out_failure(X)
		println("[businesslogic] | [State] invalidTokenId | Entry point.")
	} Goto running
	    
	State pickUpCar {
		println("[businesslogic] | [State] pickUpCar | Entry point.")
		println("[businesslogic] | [State] pickUpCar | Telling the transport trolley to pick up the car at the parking slot n...")
		forward logicaltransporttrolley -m transport_trolley_car_pickup : transport_trolley_car_pickup($SLOTNUM)
		[# 
			STATUS_PARKING_AREA[SLOTNUM - 1] = "FREE"
			SLOTNUM_PICKUP = SLOTNUM
			val P1 =  STATUS_PARKING_AREA[0]
			val P2 =  STATUS_PARKING_AREA[1]
			val P3 =  STATUS_PARKING_AREA[2]
			val P4 =  STATUS_PARKING_AREA[3]
			val P5 =  STATUS_PARKING_AREA[4]
			val P6 =  STATUS_PARKING_AREA[5]
			car_pickup_request = true
		#]
		emit status_parking_slots : status_parking_slots($P1, $P2, $P3, $P4, $P5, $P6)
		println("[businesslogic] | [State] pickUpCar | Exit point.")
	} Goto running
	
	State pickUpCarFinished {
		println("[businesslogic] | [State] pickUpCarFinished | Entry point.")
		println("[businesslogic] | [State] pickUpCarFinished | Set free the parking slot n. $SLOTNUM_PICKUP")
		[# 
			parking_slots.add(SLOTNUM_PICKUP) 
			outdoor_area_free = false
			car_pickup_request = false
		#]
		println("[businesslogic] | [State] pickUpCarFinished | Telling the client to go away...")
		replyTo car_pickup with accept_out_success : accept_out_success(X)
		println("[businesslogic] | [State] pickUpCarFinished | Entry point.")
	} Goto running
	
	State setFreeOutdoorArea {
		println("[businesslogic] | [State] setFreeOutdoorArea | Entry point.")
		println("[businesslogic] | [State] setFreeOutdoorArea | The sonar has notified that the car has left the outdoor area.")
		[# outdoor_area_free = true #]
		println("[businesslogic] | [State] setFreeOutdoorArea | Exit point.")
	} Goto running
		
	State setOccupiedOutdoorArea {
		println("[businesslogic] | [State] setOccupiedOutdoorArea | Entry point.")
		println("[businesslogic] | [State] setOccupiedOutdoorArea | The sonar has notified that the car has entered the outdoor area.")
		[# outdoor_area_free = false #]
		println("[businesslogic] | [State] setOccupiedOutdoorArea | Exit point.")
	} Goto running
	
	
}