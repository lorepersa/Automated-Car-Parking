
System first_model

Event     temperature                     : temperature( C )
Event     temperature_high                : temperature_high( X )
Event     temperature_low                 : temperature_low( X )
Request   query_state_logical_temperature : query_state_logical_temperature( X )
Reply     logical_temperature_high         : logical_temperature_high( X )
Reply     logical_temperature_low          : logical_temperature_low( X )

Dispatch  input_temperature               : input_temperature( T )

Context ctxFirstModel  ip [host="localhost" port=8053]


QActor physicalthermometer context ctxFirstModel {
	State init initial {	 
		println("[physicalthermometer] | [State] init | Entry point.")
		println("[physicalthermometer] | [State] init | Exit point.")
   	} Goto wait
   	
   	State wait {
   		println("[physicalthermometer] | [State] wait | Entry point.")
   		onMsg(input_temperature : input_temperature(T)) {
   			[# val T = payloadArg(0).toFloat() #]
   			emit temperature : temperature($T)
   		}
   		println("[physicalthermometer] | [State] wait | Exit point.")
   	} Transition t0
   	whenMsg input_temperature -> wait
   	
}

QActor logicalthermometer context ctxFirstModel {
	[#
		var TMAX = 35.0f
		var T = 0.0f
		var over_TMAX = false
	#]
	
	State init initial {
		println("[logicalthermometer] | [State] init | Entry point.")
		[#
			TMAX = 35.0f
			T = 0.0f
			over_TMAX = false
		#]
		println("[logicalthermometer] | [State] init | TMAX: $TMAX.")
		println("[logicalthermometer] | [State] init | Exit point.")
	} Goto handleTemperatureEvent
	
	/**
   	 * Each time a temperature(C) event is received handle that event.
   	 * 
   	 * When a transition from temperature lower or equal to TMAX to greater than TMAX
   	 * is intercepted then emit an temperature_high event.
   	 * 
   	 * When a transition from temperature greater than TMAX to lower or equal to TMAX
   	 * is intercepted then emit an temperature_low event.
   	 */
	State handleTemperatureEvent {
		println("[logicalthermometer] | [State] handleTemperatureEvent | Entry point.")
		onMsg(temperature : temperature(C)) {
			[# T = payloadArg(0).toFloat() #] 
			println("[logicalthermometer] | [State] handleTemperatureEvent | Received event temperature: $T.")
			if [# over_TMAX #] {
				
				// Case 1: Previous temperature higher than TMAX
				
				if [# T <= TMAX #] {
					
					// Case 1.1: Current temperature lower or equal TMAX. Now emit an temperature_low event.
					
					println("[logicalthermometer] | [State] handleTemperatureEvent | Emit temperature_low.")
					[# over_TMAX = false #]
					emit temperature_low : temperature_low(X)
				}
			} else {
				
				// Case 2: Previous temperature lower or equal to TMAX
				
				if [# T > TMAX #] {
					
					// Case 2.1: Current temperature greater than TMAX. Now emit an temperature_high event.
					
					println("[logicalthermometer] | [State] handleTemperatureEvent | Emit temperature_high.")
					[# over_TMAX = true #]
					emit temperature_high : temperature_high(X)
				}
			}
		} // end onMsg
		
		println("[logicalthermometer] | [State] handleTemperatureEvent | Exit point.")
	} Transition t_temp_filter
	whenEvent temperature -> handleTemperatureEvent
	whenRequest query_state_logical_temperature -> sendLogicalTemperature
	
	State sendLogicalTemperature {
		println("[logicalthermometer] | [State] sendLogicalTemperature | Entry point.")
		onMsg(query_state_logical_temperature : query_state_logical_temperature(X)) {
			if [# T > TMAX #] {
				replyTo query_state_logical_temperature with logical_temperature_high : logical_temperature_high(X)
			} else {
				replyTo query_state_logical_temperature with logical_temperature_low : logical_temperature_low(X)
			}
		}
		println("[logicalthermometer] | [State] sendLogicalTemperature | Exit point.")
	} Goto handleTemperatureEvent
}